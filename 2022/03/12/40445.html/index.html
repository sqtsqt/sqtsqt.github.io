<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="数据结构与算法, 申乔天的blog">
    <meta name="description" content="数据结构与算法1. 概述1.1 算法算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>数据结构与算法 | 申乔天的blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">申乔天的blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">申乔天的blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/sqtsqt" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/sqtsqt" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/19.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">数据结构与算法</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">
                                <span class="chip bg-color">数据结构与算法</span>
                            </a>
                        
                            <a href="/tags/java/">
                                <span class="chip bg-color">java</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-03-12
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    35.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    158 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="1-1-算法"><a href="#1-1-算法" class="headerlink" title="1.1 算法"></a>1.1 算法</h4><p>算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p>
<p>算法是独立存在的一种解决问题的方法和思想。</p>
<p>对于算法而言，实现的语言并不重要，重要的是思想。</p>
<h4 id="1-2-数据结构"><a href="#1-2-数据结构" class="headerlink" title="1.2 数据结构"></a>1.2 数据结构</h4><p>数据结构就是把数据组织起来，为了更方便地使用数据我们为了解决问题，需要将数据保存下来，然后根据数据的存储方式来设计算法实现进行处理，那么数据的存储方式不同就会导致需要不同的算法进行处理。我们希望算法解决问题的效率越快越好，于是我们就需要考虑数据究竟如何保存的问题，这就是数据结构。</p>
<p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。</p>
<p>程序 &#x3D; 数据结构 + 算法</p>
<p>数据结构是算法的基础。</p>
<h4 id="1-3-线性结构与非线性结构"><a href="#1-3-线性结构与非线性结构" class="headerlink" title="1.3 线性结构与非线性结构"></a>1.3 线性结构与非线性结构</h4><ul>
<li>线性结构</li>
</ul>
<p>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。</p>
<p>线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。</p>
<p>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素结点存放数据元素以及相邻元素的地址信息。</p>
<p>线性结构常见的有：数组、队列、链表和栈。</p>
<ul>
<li>非线性结构</li>
</ul>
<p>二维数组，多维数组，广义表，树结构，图结构。</p>
<h3 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>栈是限制插入和删除只能在一个位置上进行的线性表。其中，允许插入和删除的一端位于表的末端，叫做栈顶（top），不允许插入和删除的另一端叫做栈底（bottom）。对栈的基本操作有 ****PUSH（压栈）****和 ****POP （出栈）*<em><strong>，前者相当于表的插入操作（向栈顶插入一个元素），后者则是删除操作（删除一个栈顶元素）。栈是一种</strong></em>*后进先出（LIFO）****的数据结构，最先被删除的是最近压栈的元素。</p>
<h4 id="2-2-栈实现"><a href="#2-2-栈实现" class="headerlink" title="2.2 栈实现"></a>2.2 栈实现</h4><p>由于栈是一个表，因此任何实现表的方法都可以用来实现栈。主要有两种方式，链表实现和数组实现。</p>
<ul>
<li>链表实现栈</li>
</ul>
<p>可以使用单链表来实现栈。通过在表顶端插入一个元素来实现 PUSH，通过删除表顶端元素来实现 POP。使用链表方式实现的栈又叫<em><strong>动态栈</strong></em>。动态栈有链表的部分特性，即元素与元素之间在物理存储上可以不连续，但是功能有些受限制，动态栈只能在栈顶处进行插入和删除操作，不能在栈尾或栈中间进行插入和删除操作</p>
<ul>
<li>数组实现栈</li>
</ul>
<p>栈也可以用数组来实现。使用数组方式实现的栈叫<em><strong>静态栈</strong></em>。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps27EA.tmp.jpg" alt="img"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.nio.file.OpenOption;
import java.util.Arrays;

public class ArrayStack &#123;

    &#x2F;**
     * 栈的大小
     *&#x2F;
    private int maxStack;

    &#x2F;**
     * 数组用来模拟栈
     *&#x2F;
    private int[] stack;

    &#x2F;**
     * 表示栈顶所在的位置，默认情况下如果没有数据时，使用-1
     *&#x2F;
    private int top &#x3D; -1;


    public ArrayStack(int maxStack)&#123;
        this.maxStack &#x3D; maxStack;
        stack &#x3D; new int[maxStack];
    &#125;


    &#x2F;**
     * 1.压栈
     * 2.弹栈
     * 3.判断是否是空栈
     * 4.当前栈中是否是满栈
     *&#x2F;

    &#x2F;**
     * 判断是否已经满栈
     *&#x2F;
    public boolean isFull()&#123;
       return this.top &#x3D;&#x3D; this.maxStack-1;
    &#125;

    &#x2F;**
     * 判断栈是否是空栈
     *&#x2F;
    public boolean isEmpty()&#123;
        return this.top &#x3D;&#x3D; -1;
    &#125;


    &#x2F;**
     * 压栈
     *&#x2F;
    public void push(int val)&#123;
        &#x2F;&#x2F;是否已经栈满
        if (isFull())&#123;
            throw new RuntimeException(&quot;此栈已满&quot;);
        &#125;

        top++;

        stack[top] &#x3D; val;

    &#125;

    &#x2F;*
    * 弹栈
     *&#x2F;
    public int pop()&#123;
        &#x2F;&#x2F;如果栈中是空
        if (isEmpty())&#123;
            throw new RuntimeException(&quot;空栈，未找到数据&quot;);
        &#125;

        int value &#x3D; stack[top];
        top--;
        return value;

    &#125;


    &#x2F;**
     * 查看栈中所有元素
     *&#x2F;
    public void list()&#123;

        &#x2F;&#x2F;是否是空栈
        if (isEmpty())&#123;
            throw new RuntimeException(&quot;空栈，未找到数据&quot;);
        &#125;
        for (int i&#x3D;0;i&lt;stack.length;i++)&#123;
            System.out.printf(&quot;stack[%d]&#x3D;%d\n&quot;,i,stack[i]);
        &#125;

    &#125;

    &#x2F;**
     * 栈中元素存在的个数
     * @return
     *&#x2F;
    public int length()&#123;
        return this.top+1;
    &#125;


    &#x2F;**
     * 判断是否是一个运算符  + - * &#x2F;
     *
     *&#x2F;
    public boolean isOper(char v)&#123;
        return v&#x3D;&#x3D;&#39;+&#39;||v&#x3D;&#x3D;&#39;-&#39;||v&#x3D;&#x3D;&#39;*&#39;||v&#x3D;&#x3D;&#39;&#x2F;&#39;;
    &#125;

    &#x2F;**
     * 判断运算符优先级  使用数字表示优先级大小，数字越大的优先级越大
     *&#x2F;

    public int priority(int oper)&#123;
        if (oper&#x3D;&#x3D;&#39;*&#39;||oper&#x3D;&#x3D;&#39;&#x2F;&#39;)&#123;
            return 1;
        &#125;else if (oper&#x3D;&#x3D;&#39;+&#39;||oper&#x3D;&#x3D;&#39;-&#39;)&#123;
            return 0;
        &#125;else &#123;
            return -1;
        &#125;
    &#125;

    &#x2F;**
     * 获取栈顶数据
     * @return
     *&#x2F;
    public int peek()&#123;
        return this.stack[top];
    &#125;

    &#x2F;**
     * 获取栈的容量
     *&#x2F;
    public int stackLength()&#123;
        return this.stack.length;
    &#125;

    &#x2F;**
     * 计算两个数进行运算后的结果
     * 2-3
     * 3:num1,2:num2
     *&#x2F;
    public int calculate(int num1,int num2,int oper)&#123;
        &#x2F;&#x2F;计算结果
        int result &#x3D; 0;
        switch (oper)&#123;
            case &#39;+&#39;:
                result &#x3D; num1+num2;
                break;
            case &#39;-&#39;:
                result &#x3D; num2-num1;
                break;
            case &#39;*&#39;:
                result &#x3D; num1*num2;
                break;
            case &#39;&#x2F;&#39;:
                result &#x3D; num2&#x2F;num1;
                break;

                default:
                    break;

        &#125;
        return result;
    &#125;


&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h3><h4 id="3-1-链表-Linked-List-（单链表"><a href="#3-1-链表-Linked-List-（单链表" class="headerlink" title="3.1 链表(Linked List)（单链表)"></a>3.1 链表(Linked List)（单链表)</h4><p>链表是一种物理存储单元上非连续，非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps1516.tmp.jpg" alt="img"> </p>
<p>特点：</p>
<ol>
<li><p>链表是以结点形式存储的，是链式存储</p>
</li>
<li><p>每个结点包含data区域和next区域</p>
</li>
<li><p>如上图各个结点并不是连续存储的</p>
</li>
<li><p>链表分带头结点链表和没有带头结点链表，根据实际的需求来确定</p>
</li>
</ol>
<p>带头结点链表逻辑结构</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps1527.tmp.jpg" alt="img"> </p>
<p>需求：</p>
<p>根据带有头部的单链表，实现商品增删改查，并且也可以针对商品已编号进行排序，完成排行榜</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GoodsNode &#123;

    public int gId;
    public String gName;
    public double gProce;

    &#x2F;&#x2F;指针指向下一个结点
    public GoodsNode next;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="3-2-双向链表"><a href="#3-2-双向链表" class="headerlink" title="3.2 双向链表"></a>3.2 双向链表</h4><p><strong>双向链表</strong>也叫双链表，是链表的一种，它的每个数据结点中都有<strong>两个指针</strong>，分别指向<strong>直接后继</strong>和<strong>直接前驱</strong>。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps279C.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps27AC.tmp.jpg" alt="img"> </p>
 <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GoodsNode2 &#123;
    public int gId;
    public String gName;
    public double gProce;

    &#x2F;&#x2F;指针指向下一个结点
    public GoodsNode2 next;
    &#x2F;&#x2F;指针指向上一个结点
    public GoodsNode2 pre;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-3-单向环形链表（约瑟夫问题）"><a href="#3-3-单向环形链表（约瑟夫问题）" class="headerlink" title="3.3 单向环形链表（约瑟夫问题）"></a>3.3 单向环形链表（约瑟夫问题）</h4><p>采用一个单项环形链表来处理（<em>可以带表头也可以不带表头</em>）,具体使用头结点还是不带头结点，后面会具体分析。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps3D34.tmp.jpg" alt="img"> </p>
<p><strong>约瑟夫问题（约瑟夫环）</strong></p>
<p>​    设编号为1,2…，n的n个人围坐一圈，约定编号为k(1&lt;&#x3D;k&lt;&#x3D;n)的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Boy &#123;

    &#x2F;&#x2F;结点编号
    private int no;

    &#x2F;&#x2F;指向下一个节点
    private Boy next;

    public Boy(int no) &#123;
        this.no &#x3D; no;
    &#125;

    public int getNo() &#123;
        return no;
    &#125;

    public void setNo(int no) &#123;
        this.no &#x3D; no;
    &#125;

    public Boy getNext() &#123;
        return next;
    &#125;

    public void setNext(Boy next) &#123;
        this.next &#x3D; next;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CircleSingleLinkedList &#123;

    private Boy first &#x3D; new Boy(-1);

    &#x2F;**
     * 构建环形链表   5
     *&#x2F;
    public void addBoy(int nums)&#123;
        if (nums&lt;1)&#123;
            System.out.println(&quot;数据不正确&quot;);
            return;
        &#125;

        Boy temp &#x3D; null;

        for (int i&#x3D;1;i&lt;&#x3D;nums;i++)&#123;

            Boy boy &#x3D; new Boy(i);

            &#x2F;**
             * 判断你是否是第一个小孩
             *&#x2F;
            if (i&#x3D;&#x3D;1)&#123;
                first &#x3D; boy;
                first.setNext(first);
                temp &#x3D; first;
            &#125;else &#123;
                temp.setNext(boy);
                boy.setNext(first);
                temp &#x3D; boy;
            &#125;

        &#125;

    &#125;

    &#x2F;**
     * 查看环形链表中的节点
     *&#x2F;
    public void showBoy()&#123;
        if (first &#x3D;&#x3D; null)&#123;
            System.out.println(&quot;链表为空..&quot;);
            return;
        &#125;

        Boy boy &#x3D; first;
        while (true)&#123;
            System.out.printf(&quot;小孩子的编号%d\n&quot;,boy.getNo());
            if (boy.getNext() &#x3D;&#x3D; first)&#123;
                break;
            &#125;
            boy &#x3D; boy.getNext();

        &#125;
    &#125;

    &#x2F;**
     * 当调用该方法输入第几个小孩子开始数数，数几次，环形链表中一共几个小孩
     * @param startNo
     * @param countNum
     * @param nums
     *&#x2F;
    public void countBoy(int startNo,int countNum,int nums)&#123;
        if (first &#x3D;&#x3D; null||startNo &lt;1 || startNo &gt;nums)&#123;
            System.out.println(&quot;参数输入有错误...&quot;);
            return;
        &#125;

        &#x2F;**
         * 定义辅助指针，指向的是环形单链表中的最后一个节点
         *&#x2F;
        Boy helper &#x3D; first;
        while (true)&#123;
            if (helper.getNext() &#x3D;&#x3D; first)&#123;
                break;
            &#125;
            helper &#x3D; helper.getNext();
        &#125;

        &#x2F;**
         * 寻找起始位置,把first定义为起始位置
         *&#x2F;
        for (int j&#x3D;0;j&lt;startNo-1;j++)&#123;
            first &#x3D; first.getNext();
            helper &#x3D; helper.getNext();
        &#125;


        &#x2F;**
         * 当小孩进行报数时，数到m的孩子进行出列，让first和helper移动m-1次即可，找到了
         * 出列孩子
         *&#x2F;
        while (true)&#123;
            if (helper &#x3D;&#x3D; first)&#123;
                break;
            &#125;

            for (int j&#x3D;0;j&lt;countNum-1;j++)&#123;
                first &#x3D; first.getNext();
                helper &#x3D; helper.getNext();
            &#125;

            System.out.printf(&quot;小孩子%d 出列\n&quot;,first.getNo());
            first &#x3D; first.getNext();
            helper.setNext(first);

        &#125;

        System.out.printf(&quot;最后出圈的小孩编号%d\n&quot;,first.getNo());
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-稀疏数组"><a href="#4-稀疏数组" class="headerlink" title="4. 稀疏数组"></a>4. 稀疏数组</h3><h4 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h4><p>压缩条件：</p>
<ol>
<li><p>原数组中存在大量的无效数据，占据了大量的存储空间，真正有用的数据很少</p>
</li>
<li><p>压缩存储可以节省储存空间，避免资源的不必要的浪费，在数据序列化到磁盘时，压缩存储可以提高IO效率。</p>
</li>
</ol>
<p>稀疏数组处理方法：</p>
<ol>
<li><p>记录数组一共有几行几列，有多少个不同的值</p>
</li>
<li><p>把具有不同值元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。</p>
</li>
</ol>
<h4 id="4-2-实现步骤"><a href="#4-2-实现步骤" class="headerlink" title="4.2 实现步骤"></a>4.2 <strong>实现步骤</strong></h4><p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsD8E1.tmp.jpg" alt="img"> </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SparseArray &#123;

    public static void main(String[] args) &#123;

        &#x2F;**
         * 1.模拟出来棋盘数据，使用二维数组
         *&#x2F;
        int[][] array &#x3D; new int[11][11];
        array[1][2] &#x3D; 1;
        array[2][4] &#x3D; 2;

        &#x2F;&#x2F;打印棋盘查看效果
        for (int[] row :array)&#123;
            for (int val :row)&#123;
                System.out.printf(&quot;%d\t&quot;,val);
            &#125;
            System.out.println();
        &#125;

        &#x2F;**
         * 需要把如上的二维数组中有效数据压缩至稀疏数组中去
         *&#x2F;
        &#x2F;&#x2F;计算二维数组中有效数据
        int sum &#x3D; 0;
        for (int i&#x3D;0;i&lt;11;i++)&#123;
            for (int j&#x3D;0;j&lt;11;j++)&#123;
                if (array[i][j] !&#x3D;0)&#123;
                    sum++;
                &#125;
            &#125;
        &#125;

        &#x2F;&#x2F;定义稀疏数组
        int [][] sparseArray &#x3D; new int[sum+1][3];
        sparseArray[0][0] &#x3D; 11;&#x2F;&#x2F;行
        sparseArray[0][1] &#x3D; 11;&#x2F;&#x2F;列
        sparseArray[0][2] &#x3D; sum;&#x2F;&#x2F;有效数据个数

        &#x2F;&#x2F;把有效数据存放至稀疏数组中去
        int count&#x3D; 0;
        for(int i&#x3D;0;i&lt;11;i++)&#123;&#x2F;&#x2F;行的索引
            for (int j&#x3D;0;j&lt;11;j++)&#123;&#x2F;&#x2F;列的索引
                &#x2F;&#x2F;判断是否是有效数据
                if (array[i][j] !&#x3D;0)&#123;
                    count++;
                    sparseArray[count][0] &#x3D; i;
                    sparseArray[count][1] &#x3D; j;
                    sparseArray[count][2] &#x3D; array[i][j];
                &#125;
            &#125;
        &#125;

        &#x2F;**
         * 打印稀疏数组
         *&#x2F;
        for (int i&#x3D;0;i&lt;sparseArray.length;i++)&#123;
            System.out.printf(&quot;%d,%d,%d\t&quot;,sparseArray[i][0],sparseArray[i][1],sparseArray[i][2]);
        &#125;


        &#x2F;**
         * 把稀疏数组转原始二维数组（面试题）
         *&#x2F;

        int[][] oldArray &#x3D; new int[sparseArray[0][0]][sparseArray[0][1]];

        for (int i&#x3D;1;i&lt;&#x3D;count;i++)&#123;
            oldArray[sparseArray[i][0]][sparseArray[i][1]] &#x3D; sparseArray[i][2];
        &#125;

        System.out.println(&quot;---------------------------------------------------&quot;);

        &#x2F;**
         * 原始二维数组棋盘
         *&#x2F;
        for (int[] row:oldArray)&#123;
            for (int val:row)&#123;
                System.out.printf(&quot;%d\t&quot;,val);
            &#125;
            System.out.println();
        &#125;


    &#125;


&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-队列"><a href="#5-队列" class="headerlink" title="5 队列"></a>5 <strong>队列</strong></h3><h4 id="5-1-队列介绍"><a href="#5-1-队列介绍" class="headerlink" title="5.1 队列介绍"></a>5.1 <strong>队列介绍</strong></h4><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsC954.tmp.jpg" alt="img"> </p>
<p>1、 队列是一个有序列表，可以用数    组和链表来实现</p>
<p>2、 队列先进先出，即是先入队列的数据最先被取出，后存入的数据后取出。</p>
<h4 id="5-2-数组模拟队列场景"><a href="#5-2-数组模拟队列场景" class="headerlink" title="5.2 数组模拟队列场景"></a>5.2 <strong>数组模拟队列场景</strong></h4><p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsC965.tmp.jpg" alt="img"> </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrayQueue &#123;

    private int[] array;

    private int maxSize;

    private int frontPoint;

    private int rearPoint;


    public ArrayQueue(int maxSize)&#123;
        this.maxSize &#x3D; maxSize;
        array  &#x3D; new int[maxSize];

        frontPoint &#x3D; -1;
        rearPoint &#x3D; -1;

    &#125;

    &#x2F;**
     * 判断当前队列是否已满
     *&#x2F;
    public boolean isFull()&#123;
        return rearPoint &#x3D;&#x3D; maxSize-1;
    &#125;

    &#x2F;**
     * 判断是否是空队列
     *&#x2F;
    public boolean isEmpty()&#123;
        return frontPoint &#x3D;&#x3D; rearPoint;
    &#125;

    &#x2F;**
     * 添加元素进入队列
     *&#x2F;
    public void add(int n)&#123;
        &#x2F;&#x2F;判断是否已满
        if (isFull())&#123;
            System.out.println(&quot;队列已满&quot;);
            return;
        &#125;
        rearPoint++;
        array[rearPoint] &#x3D; n;
    &#125;

    &#x2F;**
     * 获取队列元素并且删除元素，出队列
     *&#x2F;
    public int get()&#123;
        if (isEmpty())&#123;
            throw new RuntimeException(&quot;空队列&quot;);
        &#125;
        frontPoint++;
        return array[frontPoint];
    &#125;

    &#x2F;**
     * 查看队列中的元素
     *&#x2F;
    public void findQueue()&#123;
        if (isEmpty())&#123;
            throw new RuntimeException(&quot;空队列&quot;);
        &#125;
        for (int i&#x3D;0;i&lt;array.length;i++)&#123;
            System.out.printf(&quot;array[%d]&#x3D;%d\n&quot;,i,array[i]);
        &#125;
    &#125;

    &#x2F;**
     * 查看队头元素，不能是出队列
     *&#x2F;
    public int frontQueue()&#123;
        if (isEmpty())&#123;
            throw new RuntimeException(&quot;空队列&quot;);
        &#125;
        return array[frontPoint+1];
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="6-时间复杂度"><a href="#6-时间复杂度" class="headerlink" title="6 时间复杂度"></a>6 <strong>时间复杂度</strong></h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><p>​    在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，渐近时间复杂度又称之为时间复杂度。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps768B.tmp.jpg" alt="img"> </p>
<h4 id="6-2-常见的时间复杂度"><a href="#6-2-常见的时间复杂度" class="headerlink" title="6.2 常见的时间复杂度"></a>6.2 <strong>常见的时间复杂度</strong></h4><p>1、 常数时间</p>
<p>若对于一个算法，的上界与输入大小无关，则称其具有****常数时间****，记作O(1)时间</p>
<p>T(n)  &#x3D;1</p>
<p>2、 对数时间</p>
<p>若算法的<strong>T</strong>(<strong>n</strong>) &#x3D;<em><strong>*O(log*</strong></em><em>*<em>*<em>n*</em>*</em>*</em>***)*<em><strong>，则称其具有</strong></em>*对数时间****。</p>
<p>int I &#x3D; 1;</p>
<p>while(i&lt;n){</p>
<p> i&#x3D;i*2;</p>
<p>}</p>
<p>x&#x3D;log2^n  O(log2n)</p>
<p>3、 幂对数时间</p>
<p>对于某个常数<strong>k</strong>，若算法的<strong>T</strong>(<strong>n</strong>) &#x3D; O((log<strong>n</strong>))，则称其具有<em><strong>*幂对数时间*</strong></em></p>
<p>4、 次线性时间</p>
<p>对于一个算法，若其匹配<strong>T</strong>(<strong>n</strong>) &#x3D; o(<strong>n</strong>)，则其时间复杂度为**<u>次线性时间</u>（****sub-linear time*<em><strong>或</strong></em>*sublinear time****）。</p>
<p>5、 线性时间</p>
<p>如果一个算法的时间复杂度为O(n)，则称这个算法具有线性时间，O(n)时间。</p>
<p>for(i&#x3D;1;i&lt;&#x3D;n;++i){</p>
<p> j&#x3D;I;</p>
<p>j++;</p>
<p>}</p>
<p>6、 线性对数时间</p>
<p>若一个算法时间复杂度T(n) &#x3D; O(nlog n)，则称这个算法具有线性对数时间。</p>
<p>7、 指数时间</p>
<p>若<strong>T</strong>(<strong>n</strong>) 是以 2为上界，其中 poly(<strong>n</strong>) 是<strong>n</strong>的多项式，则算法被称为<em><strong>*指数时间*</strong></em></p>
<p>常见的时间复杂度对应图：</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps769B.tmp.jpg" alt="img"> </p>
<p>结论：</p>
<p>1、 常见的算法时间复杂度由小到大依次为：O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n2)&lt;O(n3)&lt;O(nk)&lt;O(2n)</p>
<p>2、 尽可能的避免使用指数阶的算法</p>
<h4 id="6-3-平均和最坏时间复杂度"><a href="#6-3-平均和最坏时间复杂度" class="headerlink" title="6.3 平均和最坏时间复杂度"></a>6.3 <strong>平均和最坏时间复杂度</strong></h4><p><strong>平均时间复杂度</strong>是指所有可能的输入实例均以等概率的出现情况下得到算法的运行时间</p>
<p><strong>最坏时间复杂度</strong>，一般讨论的时间复杂度均是最坏情况下的时间复杂度，这样做的原因是最坏情况下的时间复杂度是算法在任何输入实例上运行的界限，这就保证了算法的运行时间不会比最坏情况更长。</p>
<p><strong>平均时间复杂度和最坏时间复杂度</strong>一样，这就需要根据算法不同而不同了。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps144E.tmp.jpg" alt="img"></p>
<h3 id="7-排序算法"><a href="#7-排序算法" class="headerlink" title="7 排序算法"></a>7 排序算法</h3><h4 id="7-1-排序分类"><a href="#7-1-排序分类" class="headerlink" title="7.1 排序分类"></a>7.1 排序分类</h4><ul>
<li><p>内部排序：将所有的数据都加载到内部存储器上进行排序</p>
</li>
<li><p>外部排序：数据量多大，无法全部加载到内存中，需要借助外部存储（文档）进行排序</p>
</li>
</ul>
<p>算法分类图：</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsC801.tmp.jpg" alt="img"></p>
<h4 id="7-2-基数排序"><a href="#7-2-基数排序" class="headerlink" title="7.2 基数排序"></a>7.2 基数排序</h4><h5 id="7-2-1-概述"><a href="#7-2-1-概述" class="headerlink" title="7.2.1 概述"></a>7.2.1 概述</h5><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，****基数排序法是属于稳定性的排序****，其时间复杂度为O (nlog(r)m)。</p>
<h5 id="7-2-2-原理"><a href="#7-2-2-原理" class="headerlink" title="7.2.2 原理"></a>7.2.2 原理</h5><p>讲所有的待比较数值统一设置为同样的数位长度，位数比较短的数前面补零，然后从最地位开始依次进行一次排序，这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsF139.tmp.jpg" alt="img"> </p>
<h5 id="7-2-3-实现"><a href="#7-2-3-实现" class="headerlink" title="7.2.3 实现"></a>7.2.3 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RadixSort &#123;
    public static void sort(int[] number,int a)&#123; &#x2F;&#x2F;a表示最高几位数
        int m &#x3D; 0;
        int n &#x3D; 1;
        int k &#x3D; 1;&#x2F;&#x2F;表示在第几位数
        int[][] sort &#x3D; new int[10][number.length];  &#x2F;&#x2F;数组的第一维表示可能的余数0-9
        int[] sort1 &#x3D; new int[10]; &#x2F;&#x2F;数组sort[i]用来表示该位是i的数的个数

        while (k &lt; a+1)&#123;
            for (int i&#x3D;0;i &lt; number.length;i++)&#123;
                int num &#x3D; ((number[i]&#x2F;n)%10);
                sort[num][sort1[num]] &#x3D; number[i];
                sort1[num]++;
            &#125;
            for (int i&#x3D;0;i &lt; 10;i++)&#123;
                if(sort1[i]!&#x3D;0)&#123;
                    for (int j&#x3D;0;j &lt;sort1[i];j++)&#123;
                        number[m] &#x3D; sort[i][j];
                        m++;
                    &#125;
                    sort1[i]&#x3D;0;
                &#125;
            &#125;
            m &#x3D; 0;
            n &#x3D; n*10;
            k++;
        &#125;
    &#125;
    public static void main(String[] args)
    &#123;
        int[] data &#x3D; &#123;73, 22, 93, 43, 55, 14, 28, 65, 39, 81, 33, 100&#125;;
        sort(data,3);
        for(int i &#x3D; 0; i &lt; data.length; i++)
        &#123;
            System.out.print(data[i] + &quot; &quot;);
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="7-3-冒泡排序"><a href="#7-3-冒泡排序" class="headerlink" title="7.3 冒泡排序"></a>7.3 冒泡排序</h4><h5 id="7-3-1-概述"><a href="#7-3-1-概述" class="headerlink" title="7.3.1 概述"></a>7.3.1 概述</h5><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。</p>
<p>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p>
<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p>
<h5 id="7-3-2-原理"><a href="#7-3-2-原理" class="headerlink" title="7.3.2 原理"></a>7.3.2 原理</h5><p><strong>冒泡排序</strong>的原理如下：</p>
<ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
</li>
</ol>
<h5 id="7-3-3-时间复杂度"><a href="#7-3-3-时间复杂度" class="headerlink" title="7.3.3 时间复杂度"></a>7.3.3 时间复杂度</h5><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 <img src="https://bkimg.cdn.bcebos.com/formula/0aaf4f8c3ac9f82d6a7882cd121e566b.svg" alt="img">  和记录移动次数 <img src="https://bkimg.cdn.bcebos.com/formula/2a7f4d616d4c16dbf634e349d641b055.svg" alt="img"> 均达到最小值： <img src="https://bkimg.cdn.bcebos.com/formula/03e35724822180365d0d937fbc68b9b2.svg" alt="img">  ， <img src="https://bkimg.cdn.bcebos.com/formula/9a569e56b84494c24acb31885c070f6f.svg" alt="img">  。</p>
<p>所以，冒泡排序最好的时间复杂度： <img src="https://bkimg.cdn.bcebos.com/formula/f5a1886cf2ff13d73aee4d32d363f66e.svg" alt="img"> 。</p>
<p>若初始文件是反序的，需要进行 <img src="https://bkimg.cdn.bcebos.com/formula/dd01d53f50293f756063f87e52c76000.svg" alt="img">  趟排序。每趟排序要进行 <img src="https://bkimg.cdn.bcebos.com/formula/73cdbd7376481a2b19bc38c92d4dd9ff.svg" alt="img">  次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值： <img src="https://bkimg.cdn.bcebos.com/formula/51947f4116d1beb324f5a061dac8edbd.svg" alt="img"> </p>
<p> <img src="https://bkimg.cdn.bcebos.com/formula/2cfa295e83cce099e1ff5afd4f0ba50d.svg" alt="img"> </p>
<p>冒泡排序的最坏时间复杂度为 <img src="https://bkimg.cdn.bcebos.com/formula/93e1a5d467b4fce05210acb873107e09.svg" alt="img">  。</p>
<p>综上，因此冒泡排序总的平均时间复杂度为 <img src="https://bkimg.cdn.bcebos.com/formula/93e1a5d467b4fce05210acb873107e09.svg" alt="img"> 。</p>
<p> 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 </p>
<h5 id="7-3-4-实现"><a href="#7-3-4-实现" class="headerlink" title="7.3.4 实现"></a>7.3.4 实现</h5><p>设置标志位flag，如果发生了交换flag设置为true；如果没有交换就设置为false。</p>
<p>这样当一轮比较结束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void BubbleSort1(int [] arr)&#123;
　
　
　   int temp;&#x2F;&#x2F;临时变量
　
　   boolean flag;&#x2F;&#x2F;是否交换的标志
　
　   for(int i&#x3D;0; i&lt;arr.length-1; i++)&#123;   &#x2F;&#x2F;表示趟数，一共 arr.length-1 次
　
　
　       &#x2F;&#x2F; 每次遍历标志位都要先置为false，才能判断后面的元素是否发生了交换
　
　       flag &#x3D; false;
　
　       
　
　       for(int j&#x3D;arr.length-1; j&gt;i; j--)&#123; &#x2F;&#x2F;选出该趟排序的最大值往后移动
　
　
　           if(arr[j] &lt; arr[j-1])&#123;
　
　               temp &#x3D; arr[j];
　
　               arr[j] &#x3D; arr[j-1];
　
　               arr[j-1] &#x3D; temp;
　
　               flag &#x3D; true;    &#x2F;&#x2F;只要有发生了交换，flag就置为true
　
　           &#125;
　
　       &#125;
　
　       &#x2F;&#x2F; 判断标志位是否为false，如果为false，说明后面的元素已经有序，就直接return
　
　       if(!flag) break;
　
　   &#125;
　
　&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="7-4-快速排序"><a href="#7-4-快速排序" class="headerlink" title="7.4 快速排序"></a>7.4 快速排序</h4><h5 id="7-4-1-排序流程"><a href="#7-4-1-排序流程" class="headerlink" title="7.4.1 排序流程"></a>7.4.1 排序流程</h5><p>快速排序算法通过多次比较和交换来实现排序，其排序流程如下： </p>
<ol>
<li><p>首先设定一个分界值，通过该分界值将数组分成左右两部分。 </p>
</li>
<li><p>将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于分界值，而右边部分中各元素都大于或等于分界值。</p>
</li>
<li><p>然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p>
</li>
<li><p>重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。</p>
</li>
</ol>
<h5 id="7-4-2-原理及演示"><a href="#7-4-2-原理及演示" class="headerlink" title="7.4.2 原理及演示"></a>7.4.2 原理及演示</h5><p><strong>原理：</strong></p>
<p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</p>
<p>一趟快速排序的算法是：</p>
<ol>
<li><p>设置两个变量i、j，排序开始的时候：i&#x3D;0，j&#x3D;N-1；</p>
</li>
<li><p>以第一个数组元素作为关键数据，赋值给<strong>key</strong>，即<strong>key</strong>&#x3D;A[0]； </p>
</li>
<li><p>从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于<strong>key</strong>的值A[j]，将A[j]和A[i]的值交换；</p>
</li>
<li><p>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于<strong>key</strong>的A[i]，将A[i]和A[j]的值交换； </p>
</li>
<li><p>重复第3、4步，直到i&#x3D;&#x3D;j； (3,4步中，没找到符合条件的值，即3中A[j]不小于<strong>key</strong>,4中A[i]不大于<strong>key</strong>的时候改变j、i的值，使得j&#x3D;j-1，i&#x3D;i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i&#x3D;&#x3D;j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p>
</li>
</ol>
<p><strong>排序演示：</strong></p>
<p>假设一开始序列{xi}是：5，3，7，6，4，1，0，2，9，10，8。</p>
<p>此时，ref&#x3D;5，i&#x3D;1，j&#x3D;11，从后往前找，第一个比5小的数是x8&#x3D;2，因此序列为：2，3，7，6，4，1，0，5，9，10，8。</p>
<p>此时i&#x3D;1，j&#x3D;8，从前往后找，第一个比5大的数是x3&#x3D;7，因此序列为：2，3，5，6，4，1，0，7，9，10，8。</p>
<p>此时，i&#x3D;3，j&#x3D;8，从第8位往前找，第一个比5小的数是x7&#x3D;0，因此：2，3，0，6，4，1，5，7，9，10，8。</p>
<p>此时，i&#x3D;3，j&#x3D;7，从第3位往后找，第一个比5大的数是x4&#x3D;6，因此：2，3，0，5，4，1，6，7，9，10，8。</p>
<p>此时，i&#x3D;4，j&#x3D;7，从第7位往前找，第一个比5小的数是x6&#x3D;1，因此：2，3，0，1，4，5，6，7，9，10，8。</p>
<p>此时，i&#x3D;4，j&#x3D;6，从第4位往后找，直到第6位才有比5大的数，这时，i&#x3D;j&#x3D;6，ref成为一条分界线，它之前的数都比它小，之后的数都比它大，对于前后两部分数，可以采用同样的方法来排序。</p>
<h5 id="7-4-3-实现"><a href="#7-4-3-实现" class="headerlink" title="7.4.3 实现"></a>7.4.3 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int[] qsort(int arr[],int start,int end) &#123;        
    int pivot &#x3D; arr[start];        
    int i &#x3D; start;        
    int j &#x3D; end;        
    while (i&lt;j) &#123;            
        while ((i&lt;j)&amp;&amp;(arr[j]&gt;pivot)) &#123;                
            j--;            
        &#125;            
        while ((i&lt;j)&amp;&amp;(arr[i]&lt;pivot)) &#123;                
            i++;            
        &#125;            
        if ((arr[i]&#x3D;&#x3D;arr[j])&amp;&amp;(i&lt;j)) &#123;                
            i++;            
        &#125; else &#123;                
            int temp &#x3D; arr[i];                
            arr[i] &#x3D; arr[j];                
            arr[j] &#x3D; temp;            
        &#125;        
    &#125;        
    if (i-1&gt;start) arr&#x3D;qsort(arr,start,i-1);        
    if (j+1&lt;end) arr&#x3D;qsort(arr,j+1,end);        
    return (arr);    
&#125;    
 
public static void main(String[] args) &#123;        
    int arr[] &#x3D; new int[]&#123;3,3,3,7,9,122344,4656,34,34,4656,5,6,7,8,9,343,57765,23,12321&#125;;        
    int len &#x3D; arr.length-1;        
    arr&#x3D;qsort(arr,0,len);        
    for (int i:arr) &#123;            
        System.out.print(i+&quot;\t&quot;);        
    &#125;    
&#125;
 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="7-5-插入排序"><a href="#7-5-插入排序" class="headerlink" title="7.5 插入排序"></a>7.5 插入排序</h4><h5 id="7-5-1-概述"><a href="#7-5-1-概述" class="headerlink" title="7.5.1 概述"></a>7.5.1 概述</h5><p> 插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动 。</p>
<h5 id="7-5-2-原理"><a href="#7-5-2-原理" class="headerlink" title="7.5.2 原理"></a>7.5.2 原理</h5><p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsDD92.tmp.jpg" alt="img"></p>
<h5 id="7-5-3-实现"><a href="#7-5-3-实现" class="headerlink" title="7.5.3 实现"></a>7.5.3 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;

public class InsertSort &#123;

    public static void main(String[] args) &#123;

        int[] array &#x3D; new int[]&#123;2,5,6,3,4,7,1,8&#125;;
        &#x2F;&#x2F;控制拿去每一个元素
        for(int i&#x3D;1;i&lt;array.length;i++)&#123;
            &#x2F;&#x2F;比较次数
            for (int j&#x3D;i;j&gt;&#x3D;1;j--)&#123;
                &#x2F;&#x2F;是否小于前面的元素
                if (array[j]&lt;array[j-1])&#123;
                    int temp &#x3D; 0;
                    temp &#x3D; array[j];
                    array[j] &#x3D; array[j-1];
                    array[j-1] &#x3D; temp;
                &#125;else &#123;

                    &#x2F;&#x2F;continue 与 break

                    break;
                &#125;
            &#125;

        &#125;

        System.out.println(&quot;排序后的结果：&quot;+ Arrays.toString(array));

    &#125;

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="7-6-选择排序"><a href="#7-6-选择排序" class="headerlink" title="7.6 选择排序"></a>7.6 选择排序</h4><h5 id="7-6-1-概述"><a href="#7-6-1-概述" class="headerlink" title="7.6.1 概述"></a>7.6.1 概述</h5><p>​    选择排序也属于内部排序法，是从欲排序的数据中按指定的规则选择某一个元素，再以规则交换位置后达到的排序目的。</p>
<h5 id="7-6-2-原理"><a href="#7-6-2-原理" class="headerlink" title="7.6.2 原理"></a>7.6.2 原理</h5><p>​    第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsDA84.tmp.jpg" alt="img"></p>
<h5 id="7-6-3-实现"><a href="#7-6-3-实现" class="headerlink" title="7.6.3 实现"></a>7.6.3 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;

public class SelectSort &#123;
    public static void sort(int[] arrays)&#123;
        int min&#x3D;0;
        for (int i&#x3D;0;i&lt;arrays.length;i++)&#123;
            for (int j&#x3D;arrays.length-1;j &gt; i;j--)&#123;
                if (arrays[j]&lt;arrays[i]) &#123;
                    min &#x3D; arrays[j];
                    arrays[j] &#x3D; arrays[i];
                    arrays[i] &#x3D; min;
                &#125;
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        int[] arrays &#x3D; new int[]&#123;2,6,4,1,3,7,5&#125;;
        sort(arrays);

        System.out.println(Arrays.toString(arrays));
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="7-7-希尔排序"><a href="#7-7-希尔排序" class="headerlink" title="7.7 希尔排序"></a>7.7 希尔排序</h4><h5 id="7-7-1-概述"><a href="#7-7-1-概述" class="headerlink" title="7.7.1 概述"></a>7.7.1 概述</h5><p>​    希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因 D.L.Shell 于 1959 年提出而得名。</p>
<p>​    希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</p>
<h5 id="7-7-2-原理"><a href="#7-7-2-原理" class="headerlink" title="7.7.2 原理"></a>7.7.2 原理</h5><p>​    算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行分组，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。 </p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsB3D1.tmp.jpg" alt="img"></p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsB3E1.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsB3E2.tmp.jpg" alt="img"> </p>
<p>​    由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。 </p>
<h5 id="7-7-3-算法分析"><a href="#7-7-3-算法分析" class="headerlink" title="7.7.3 算法分析"></a>7.7.3 算法分析</h5><p>希尔排序是基于插入排序的一种算法，在此算法基础之上增加了一个新的特性，提高了效率。希尔排序的时间复杂度为O（ <img src="https://bkimg.cdn.bcebos.com/formula/eb39d4c67a9cabbd3a2690a2151ee6cc.svg" alt="img"> ）， 希尔排序时间复杂度的下界是n*log2n。希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。但是比O( <img src="https://bkimg.cdn.bcebos.com/formula/c937d30f3cd06da1cd53133d8a3b4887.svg" alt="img"> )复杂度的算法快得多。并且希尔排序非常容易实现，算法代码短而简单。 此外，希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，与此同时快速排序在最坏的情况下执行的效率会非常差。</p>
<h5 id="7-7-4-实现"><a href="#7-7-4-实现" class="headerlink" title="7.7.4 实现"></a>7.7.4 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;

public class ShellSort &#123;
    public static void main(String[] args) &#123;
        int[] array&#x3D;&#123;49,38,65,97,76,13,27,49,78,34,12,64,1&#125;;
        System.out.println(&quot;排序之前：&quot; + Arrays.toString(array));

        &#x2F;**
         * 希尔排序
         *&#x2F;
        int temp &#x3D; 0;
        for (int gap&#x3D; array.length&#x2F;2;gap&gt;0;gap&#x2F;&#x3D;2)&#123;
            for (int i &#x3D; gap; i &lt; array.length; i++) &#123;
                for (int j &#x3D; i - gap;j &gt;&#x3D; 0;j-&#x3D;gap)&#123;
                    if (array[j] &gt; array[j+gap])&#123;
                        temp &#x3D; array[j];
                        array[j] &#x3D; array[j+gap];
                        array[j+gap] &#x3D; temp;
                    &#125;
                &#125;
            &#125;
        &#125;
        System.out.println(&quot;排序之后：&quot; + Arrays.toString(array));
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="7-8-归并排序"><a href="#7-8-归并排序" class="headerlink" title="7.8 归并排序"></a>7.8 归并排序</h4><h5 id="7-8-1-概述"><a href="#7-8-1-概述" class="headerlink" title="7.8.1 概述"></a>7.8.1 概述</h5><p>归并排序（Merge Sort）是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<h5 id="7-8-2-原理"><a href="#7-8-2-原理" class="headerlink" title="7.8.2 原理"></a>7.8.2 原理</h5><p>原理如下：</p>
<ol>
<li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p>
</li>
<li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置</p>
</li>
<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p>
</li>
<li><p>重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾</p>
</li>
</ol>
<p>归并排序是稳定的排序.即相等的元素的顺序不会改变.如输入记录 1(1) 3(2) 2(3) 2(4) 5(5) (括号中是记录的关键字)时输出的 1(1) 2(3) 2(4) 3(2) 5(5) 中的2 和 2  是按输入的顺序.这对要排序数据包含多个信息而要按其中的某一个信息排序,要求其它信息尽量按输入的顺序排列时很重要。归并排序的比较次数小于快速排序的比较次数，移动次数一般多于快速排序的移动次数。</p>
<h5 id="7-8-3-实现"><a href="#7-8-3-实现" class="headerlink" title="7.8.3 实现"></a>7.8.3 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MergeSort &#123;
    public static int[] mergeSort(int[] nums,int l,int h)&#123;
        if (l &#x3D;&#x3D; h)&#123;
            return new int[] &#123;nums[l]&#125;;
        &#125;
        int mid &#x3D; l + (h - l)&#x2F;2;
        int[] lift &#x3D; mergeSort(nums,l,mid);
        int[] right &#x3D; mergeSort(nums,mid+1,h);
        int[] newNum &#x3D; new int[lift.length+right.length];

        int m&#x3D;0,i&#x3D;0,j&#x3D;0;
        while (i &lt; lift.length &amp;&amp; j &lt; right.length)&#123;
            newNum[m++] &#x3D; lift[i] &lt; right[j] ? lift[i++] : right[j++];
        &#125;
        while (i &lt; lift.length)&#123;
            newNum[m++] &#x3D; lift[i++];
        &#125;
        while (i &lt; right.length)&#123;
            newNum[m++] &#x3D; right[j++];
        &#125;
        return newNum;
    &#125;

    public static void main(String[] args) &#123;
        int[] nums &#x3D; new int[] &#123; 9, 8, 7, 6, 5, 4, 3, 2, 10 &#125;;
        int[] newNums &#x3D; mergeSort(nums, 0, nums.length - 1);
        for (int x : newNums) &#123;
            System.out.println(x);
        &#125;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="8-查找算法"><a href="#8-查找算法" class="headerlink" title="8 查找算法"></a>8 查找算法</h3><p>在java程序中一般常用到<strong>四种</strong>查找方式。<strong>顺序查找（线性）</strong>，<strong>二分查找</strong>，<strong>插值查找</strong>，<strong>斐波那契查找</strong>。</p>
<h4 id="8-1-线性查找"><a href="#8-1-线性查找" class="headerlink" title="8.1 线性查找"></a>8.1 线性查找</h4><h5 id="8-1-1-概述"><a href="#8-1-1-概述" class="headerlink" title="8.1.1 概述"></a>8.1.1 概述</h5><p>线性查找又称顺序查找，是一种最简单的查找方法，它的基本思想是从第一个记录开始，逐个比较记录的关键字，直到和给定的K值相等，则查找成功；若比较结果与文件中n个记录的关键字都不等，则查找失败。</p>
<h5 id="8-1-2-实现"><a href="#8-1-2-实现" class="headerlink" title="8.1.2 实现"></a>8.1.2 实现</h5><p>在待查数据中进行顺序性轮询查找，当存在待查的数据时返回当前数据索引位置，如果不存在则返回不存在表示-1</p>
<p><strong>时间复杂度：</strong> O(N)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LinearSearch &#123;
 
    &#x2F;&#x2F;私有构造，防止外部实例化该对象
    private LinearSearch()&#123;&#125;
 
    &#x2F;&#x2F;线性查找元素
    public static int search(int[] data, int target) &#123;
        for (int i &#x3D; 0; i &lt; data.length; i++) &#123;
            if (data[i] &#x3D;&#x3D; target) &#123;
                return i;
            &#125;
        &#125;
        return -1;
    &#125;
 
    &#x2F;&#x2F;测试方法
    public static void main(String[] args) &#123;
        int[] data &#x3D; &#123;2, 9, 5, 1, 8, 7, 3, 6&#125;;
        int index &#x3D; LinearSearch.search(data, 8);
        System.out.println(index);
    &#125;
 
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class 线性查找 &#123;

    public static int search(int[] number,int key)&#123;

        int[] temp &#x3D; new int[number.length+1];
        &#x2F;&#x2F;设置末尾为监视哨
        for(int i&#x3D;0;i&lt;number.length;i++)&#123;
            temp[i] &#x3D; number[i];
        &#125;
        temp[number.length] &#x3D; key;
        int result &#x3D; 0;
        &#x2F;&#x2F;进行查找匹对
        for(int i&#x3D;0;;i++)&#123;
            if(temp[i] &#x3D;&#x3D; key)&#123;
                result &#x3D; i;
                break;
            &#125;
        &#125;
        if(result &lt; number.length)&#123;
            return result;
        &#125;else&#123;
            return -1;
        &#125;
    &#125;

    public static void main(String[] args)&#123;
        int[] number &#x3D; &#123;12,24,53241,126,52,35,5263,7&#125;;
        int key&#x3D; 52;
        System.out.println(线性查找.search(number, key));
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="8-2-二分查找-非递归"><a href="#8-2-二分查找-非递归" class="headerlink" title="8.2 二分查找(非递归)"></a>8.2 二分查找(非递归)</h4><h5 id="8-2-1-概述"><a href="#8-2-1-概述" class="headerlink" title="8.2.1 概述"></a>8.2.1 概述</h5><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p>
<h5 id="8-2-2-原理"><a href="#8-2-2-原理" class="headerlink" title="8.2.2 原理"></a>8.2.2 原理</h5><p>特点是待查询的表为有序表，设置一个左标示为0一个右标示为当前数组长度，让当前待查元素与表中间元素进行匹配，如果一致则直接返回中间索引，如果小于中间索引则让右标示等于middle，如果大于中间索引，则让左标示等于middle。</p>
<p>优缺点：<br>优点就是因为比较的次数大大减少索引效率很高<br>缺点就是要待查询的表为有序表，这就大大限制的所能操作的领域，并且只对查询效率有所优化，当修改和插入数据的时候这种效率就很低了。因为还有考虑修改或插入之后元素之间顺序的问题。</p>
<p>平均查找长度： (n+1&#x2F;n)*(log2(n+1))-1</p>
<p>时间复杂度： O（logN）</p>
<h5 id="8-2-3-实现"><a href="#8-2-3-实现" class="headerlink" title="8.2.3 实现"></a>8.2.3 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BinarySearch &#123;

    public static int halfSort(int[] data,int key)&#123;
        int left &#x3D; 0;&#x2F;&#x2F;左标记
        int right &#x3D; data.length-1;&#x2F;&#x2F;右标记
        int result &#x3D; -1;
        while(left&lt;&#x3D;right)&#123; &#x2F;&#x2F;进行中间判断
            int half &#x3D; (left+right)&#x2F;2;
            if(data[half] &#x3D;&#x3D; key)&#123;
                result &#x3D; half;
                break;
            &#125;else if(data[half] &lt; key)&#123;
                left &#x3D; half;
            &#125;else&#123;
                right &#x3D; half;
            &#125;
        &#125;
        return result;
    &#125;

    public static void main(String[] args)&#123;
        int[] number &#x3D; &#123;1,2,3,4,5,6,7,8,9,10&#125;;
        int key &#x3D; 6;
        int result &#x3D; BinarySearch.halfSort(number, key);
        if(result &#x3D;&#x3D; -1)&#123;
            System.out.println(&quot;当前数据不存在&quot;);
        &#125;else&#123;
            System.out.println(result);
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Sort &#123;

    public static void main(String[] args) &#123;
        int[] arrays &#x3D; &#123;1,4,6,8,9,10,20&#125;;
        int startIndex &#x3D; 0;
        int endIndex &#x3D; arrays.length-1;
        System.out.println(search(arrays,startIndex,endIndex,8));;

    &#125;

    public static int search(int[] arrays,int start,int end,int val)&#123;
        if (start&gt;end)&#123;
            return -1;
        &#125;
        int mid &#x3D; (start+end)&#x2F;2;
        int midVal &#x3D; arrays[mid];
        if (val&gt;midVal)&#123;
            return search(arrays,mid+1,end,val);
        &#125;else if (val&lt;midVal)&#123;
            return search(arrays,start,mid-1,val);
        &#125;else &#123;
            return mid;
        &#125;

    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="8-3-插值查找"><a href="#8-3-插值查找" class="headerlink" title="8.3 插值查找"></a>8.3 插值查找</h4><h5 id="8-3-1-概述"><a href="#8-3-1-概述" class="headerlink" title="8.3.1 概述"></a>8.3.1 概述</h5><p> 插值查找，有序表的一种查找方式。插值查找是根据查找关键字与查找表中最大最小记录关键字比较后的查找方法。插值查找基于二分查找，将查找点的选择改进为自适应选择，提高查找效率。 </p>
<h5 id="8-3-2-原理"><a href="#8-3-2-原理" class="headerlink" title="8.3.2 原理"></a>8.3.2 原理</h5><ol>
<li><p>插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。</p>
</li>
<li><p>将折半查找中的求mid索引的公式，low表示左边索引left，high表示索引right，key(findVal)是我们要查找的值。</p>
<pre class="line-numbers language-公式" data-language="公式"><code class="language-公式">mid &#x3D; (low + high)&#x2F;2 &#x3D; low + 1&#x2F;2*(high - low)  
--&gt; 
mid &#x3D; low + (key - a[low])*(high - low)&#x2F;(a[high] - a[low])
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>&#96;&#96;&#96;java<br>int mid &#x3D; left + (right - left)<em>(findVal - arr[left])&#x2F;(arr[right] - arr[left])<br>–&gt;<br>int mid &#x3D; low + (high - low)</em>(key - arr[low])&#x2F;(arr[high] - arr[low]); &#x2F;<em>插值查找</em>&#x2F;</p>
<pre class="line-numbers language-none"><code class="language-none">
##### 8.3.3 实现

&#96;&#96;&#96;java
public class InsertSelect &#123;

    public static void main(String[] args) &#123;

        int[] array &#x3D; &#123;1,2,3,4,5,6&#125;;

        int left &#x3D; 0;
        int right &#x3D; array.length-1;

        int searchVal &#x3D; 1;

        System.out.println(select(array,left,right,searchVal));

    &#125;

    public static int select(int[] array,int left,int right,int searchVal)&#123;

        &#x2F;**
         * 防止数组越界
         *&#x2F;
        if (left&gt;right || searchVal&lt;array[0] || searchVal&gt;array[array.length-1])&#123;
            return -1;
        &#125;

        int mid &#x3D; left+(right-left)*(searchVal-array[left])&#x2F;(array[right]-array[left]);
        int midValue &#x3D; array[mid];
        if (searchVal&gt;midValue)&#123;
            return select(array,mid+1,right,searchVal);
        &#125;else if (searchVal&lt;midValue)&#123;
            return select(array,left,mid-1,searchVal);
        &#125;else &#123;
            return mid;
        &#125;

    &#125;

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h4 id="8-4-黄金分割法算法（斐波那契算法）"><a href="#8-4-黄金分割法算法（斐波那契算法）" class="headerlink" title="8.4 黄金分割法算法（斐波那契算法）"></a>8.4 <strong>黄金分割法算法（斐波那契算法）</strong></h4><h5 id="8-4-1-概述"><a href="#8-4-1-概述" class="headerlink" title="8.4.1 概述"></a>8.4.1 概述</h5><p>在介绍斐波那契查找算法之前，先介绍一下很它紧密相连的一个概念——黄金分割。黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。因此被称为黄金分割。斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。</p>
<h5 id="8-4-2-原理"><a href="#8-4-2-原理" class="headerlink" title="8.4.2 原理"></a>8.4.2 原理</h5><p>斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，在数学上，斐波那契被递归方法如下定义：F(1)&#x3D;1，F(2)&#x3D;1，F(n)&#x3D;f(n-1)+F(n-2) （n&gt;&#x3D;2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）。</p>
<p>斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为F[n]，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。</p>
<p>斐波那契查找的时间复杂度还是O(log 2 n )，但是与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定。</p>
<h5 id="8-4-3-实现"><a href="#8-4-3-实现" class="headerlink" title="8.4.3 实现"></a>8.4.3 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;

public class FibonacciSelect &#123;

    public static void main(String[] args) &#123;

        int[] array &#x3D; &#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89&#125;;

        System.out.println(select(array,13));
    &#125;

    &#x2F;**
     * f[k] &#x3D; (f[k-1])+ (f[k-2])
     * @return
     *&#x2F;
    public static int[] f()&#123;

        int[] f &#x3D; new int[20];
        f[0] &#x3D; 1;
        f[1] &#x3D; 1;
        for (int i &#x3D; 2;i&lt;f.length;i++)&#123;
            f[i] &#x3D; f[i-1]+f[i-2];
        &#125;
        return f;
    &#125;


    &#x2F;**
     * mid &#x3D; low+F(k-1)-1
     * @param array
     * @param key
     * @return
     *&#x2F;
    public static int select(int[] array,int key)&#123;

        int low &#x3D; 0;
        int hight  &#x3D; array.length-1;
        int k &#x3D; 0;
        int mid &#x3D; 0;
        int[] f &#x3D; f();

        &#x2F;**
         * 找分割点
         *&#x2F;
        while (hight&gt;f[k]-1)&#123;
            k++;
        &#125;

        int[] temp &#x3D; Arrays.copyOf(array,f[k]);

        &#x2F;**
         * &#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89&#125;  -&#x3D;》&#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89，89,89,&#125;
         *&#x2F;
        for (int i &#x3D; hight+1;i&lt;temp.length;i++)&#123;
            temp[i] &#x3D; array[hight];
        &#125;

        while (low&lt;&#x3D;hight)&#123;
            mid &#x3D; low+f[k-1]-1;

            &#x2F;&#x2F; f[k-1]+f[k-2] &#x3D; f[k];
            if (key&lt;temp[mid])&#123;
                hight&#x3D;mid-1;
                k--;
            &#125;else if (key&gt;temp[mid])&#123;
                low &#x3D; mid+1;
                k-&#x3D;2;
            &#125;else&#123;
                if (mid&lt;&#x3D;hight)&#123;
                    return mid;
                &#125;else &#123;
                    return hight;
                &#125;
            &#125;
        &#125;
        return -1;
    &#125;

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="9-哈希表"><a href="#9-哈希表" class="headerlink" title="9 哈希表"></a>9 哈希表</h3><p>​    散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>​    给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<h4 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h4><ul>
<li>若关键字为<strong>k</strong>，则其值存放在<strong>f(k)<strong>的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系</strong>f</strong>为散列函数，按这个思想建立的表为散列表。</li>
<li>对不同的关键字可能得到同一散列地址，即<strong>k1≠k2</strong>，而**f(k1)&#x3D;&#x3D;f(k2)<strong>，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数</strong>f(k)**和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。</li>
<li>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</li>
</ul>
<h4 id="9-2-原理"><a href="#9-2-原理" class="headerlink" title="9.2 原理"></a>9.2 原理</h4><p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps7F9F.tmp.jpg" alt="img"></p>
<p>思路分析：</p>
<p>​    比如使用添加一个学生到校园系统中去，输入学生学号可以查找出该学生所有信息。</p>
<p>要求：</p>
<ol>
<li><p>添加学生编号时按照从低到高的顺序</p>
</li>
<li><p>使用链表来实现哈希表，该链表不带表头</p>
</li>
</ol>
<h4 id="9-3-实现"><a href="#9-3-实现" class="headerlink" title="9.3 实现"></a>9.3 实现</h4><h5 id="9-3-1-Student"><a href="#9-3-1-Student" class="headerlink" title="9.3.1 Student"></a>9.3.1 Student</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student &#123;
    public int id;
    public String name;
    &#x2F;&#x2F;指向下一个结点指针
    public Student next;

    public Student(int id, String name) &#123;
        this.id &#x3D; id;
        this.name &#x3D; name;
    &#125;

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="9-3-2-StudentLinkedList"><a href="#9-3-2-StudentLinkedList" class="headerlink" title="9.3.2 StudentLinkedList"></a>9.3.2 StudentLinkedList</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StudentLinkedList &#123;

    private Student head;
    
    &#x2F;**
     * 添加结点
     *
     *&#x2F;
    public void add(Student newStudent)&#123;

        &#x2F;&#x2F;1.如果添加时是第一个学生对象,则直接复制给第一个节点
        if (head &#x3D;&#x3D; null)&#123;
            head &#x3D; newStudent;
            return;
        &#125;

        Student temp &#x3D; head;

        while (true)&#123;
            if (temp.next &#x3D;&#x3D; null)&#123;
                break;
            &#125;
            &#x2F;&#x2F;继续往后查找
            temp &#x3D; temp.next;
        &#125;
        &#x2F;&#x2F;追加了新的结点
        temp.next &#x3D; newStudent;
    &#125;

    public void list(int no)&#123;

        if (head &#x3D;&#x3D; null)&#123;
            System.out.println(&quot;第&quot;+no+&quot;链表是空...&quot;);
            return;
        &#125;

        Student temp &#x3D; head;
        while (true)&#123;
            System.out.printf(&quot;id&#x3D;%d  name&#x3D;%s\t&quot;,temp.id,temp.name);

            if (temp.next&#x3D;&#x3D;null)&#123;
                break;
            &#125;
            temp &#x3D; temp.next;
        &#125;

        System.out.println();

    &#125;

    &#x2F;**
     * 根据学员编号查询结点  id
     *&#x2F;
    public Student findById(int id)&#123;
        if (head &#x3D;&#x3D; null)&#123;
            System.out.println(&quot;空链表...&quot;);
            return null;
        &#125;

        Student temp &#x3D; head;
        while (true)&#123;
            if (temp.id &#x3D;&#x3D; id)&#123;
                break;
            &#125;

            if (temp.next &#x3D;&#x3D; null)&#123;
                temp &#x3D; null;
                break;
            &#125;
            temp &#x3D; temp.next;
        &#125;
        return temp;
    &#125;

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="9-3-3-HashTable"><a href="#9-3-3-HashTable" class="headerlink" title="9.3.3 HashTable"></a>9.3.3 HashTable</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.sun.xml.internal.bind.v2.model.core.ID;

public class HashTable &#123;

    private StudentLinkedList[] studentLinkedLists;

    private int size;

    public HashTable(int size)&#123;
        this.size &#x3D; size;
        studentLinkedLists &#x3D; new StudentLinkedList[size];

        &#x2F;**
         * 数组中添加链表对象
         *&#x2F;
        for (int i&#x3D;0;i&lt;size;i++)&#123;
            studentLinkedLists[i] &#x3D; new StudentLinkedList();
        &#125;
    &#125;

    &#x2F;**
     * 哈希函数
     * @param sid
     * @return
     *&#x2F;
    public int hashCodes(int sid)&#123;
        return sid%size;
    &#125;

    &#x2F;**
     * 添加学员
     *&#x2F;
    public void add(Student student)&#123;
        &#x2F;&#x2F;决定了是数组中的下标
        int hashVal &#x3D; hashCodes(student.id);

        &#x2F;**
         * 添加到指定的链表中
         *&#x2F;
        studentLinkedLists[hashVal].add(student);
    &#125;

    &#x2F;**
     * 查看哈希表中的元素
     *&#x2F;
    public void list()&#123;
        for (int i&#x3D;0;i&lt;size;i++)&#123;
            studentLinkedLists[i].list(i);
        &#125;
    &#125;

    &#x2F;**
     * 根据学员编号查询
     *&#x2F;
    public void findByStudentId(int sid)&#123;
        int hashVal &#x3D; hashCodes(sid);

        Student students &#x3D; studentLinkedLists[hashVal].findById(sid);

        if (students !&#x3D;null)&#123;
            System.out.printf(&quot;在第%d条链表中找到了学员编号是:%d\n&quot;,(hashVal+1), sid);
        &#125;else &#123;
            System.out.println(&quot;整个hash表中未找到学员&quot;);
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="9-3-4-TestApp"><a href="#9-3-4-TestApp" class="headerlink" title="9.3.4 TestApp"></a>9.3.4 TestApp</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestApp &#123;

    public static void main(String[] args) &#123;

        HashTable hashTable &#x3D; new HashTable(10);
        &#x2F;**
         * 添加学员节点
         *&#x2F;
        Student student1 &#x3D; new Student(1,&quot;张三&quot;);
        Student student2 &#x3D; new Student(2,&quot;李四&quot;);
        Student student3 &#x3D; new Student(3,&quot;王五&quot;);
        Student student4 &#x3D; new Student(4,&quot;周六&quot;);

        Student student5 &#x3D; new Student(4,&quot;小七&quot;);
        hashTable.add(student1);
        hashTable.add(student2);
        hashTable.add(student3);
        hashTable.add(student4);
        hashTable.add(student5);

        hashTable.list();

        hashTable.findByStudentId(4);

    &#125;

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="10-树"><a href="#10-树" class="headerlink" title="10 树"></a>10 树</h3><h4 id="10-1-树"><a href="#10-1-树" class="headerlink" title="10.1 树"></a>10.1 树</h4><h5 id="10-1-1-概述-及比较"><a href="#10-1-1-概述-及比较" class="headerlink" title="10.1.1 概述(及比较)"></a>10.1.1 概述(及比较)</h5><p>树是一种重要的非线性数据结构，直观地看，它是数据元素（在树中称为结点）按分支关系组织起来的结构，很象自然界中的树那样。 </p>
<p>数组存储方式的分析：</p>
<ul>
<li><p>优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。</p>
</li>
<li><p>缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低<br>画出操作示意图：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1645848308034.png" alt="1645848308034"></p>
</li>
</ul>
<p>链式存储方式的分析：</p>
<ul>
<li><p>优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。</p>
</li>
<li><p>缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) </p>
<p>操作示意图：</p>
</li>
</ul>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1645848412604.png" alt="1645848412604"></p>
<p>树存储方式的分析：</p>
<ul>
<li><p>能提高数据存储，读取的效率,  比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。案例: [7, 3, 10, 1, 5, 9, 12]</p>
<p>操作示意图：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1645848470849.png" alt="1645848470849"></p>
</li>
</ul>
<h5 id="10-1-2-树示意图"><a href="#10-1-2-树示意图" class="headerlink" title="10.1.2 树示意图"></a>10.1.2 树示意图</h5><p>树的常用术语(结合示意图理解):</p>
<ol>
<li>节点</li>
<li>根节点</li>
<li>父节点</li>
<li>子节点</li>
<li>叶子节点 (没有子节点的节点)</li>
<li>节点的权(节点值)</li>
<li>路径(从root节点找到该节点的路线)</li>
<li>层</li>
<li>子树</li>
<li>树的高度(最大层数)</li>
<li>森林 :多颗子树构成森林</li>
</ol>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1645848639734.png" alt="1645848639734"></p>
<h4 id="10-2-二叉树"><a href="#10-2-二叉树" class="headerlink" title="10.2 二叉树"></a>10.2 二叉树</h4><h5 id="10-2-1-概述"><a href="#10-2-1-概述" class="headerlink" title="10.2.1 概述"></a>10.2.1 概述</h5><p>树有很多种，每个结点最多只能有两个子结点的一种形式称之为二叉树</p>
<p>二叉树分为左结点和右结点</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsD697.tmp.jpg" alt="img"> </p>
<p>如果该二叉树的所有叶子结点都在最后一层，并且结点总数是2^n-1，n是层数，则我们称之为满二叉树</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsD6A8.tmp.jpg" alt="img"> </p>
<p>如果该二叉树的所有叶子结点都在最后一层或者倒数第二层，而且最后一层的叶子结点在左边连续，倒数第二层的叶子结点在右边连续，我们称之为全完二叉树。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsD6A9.tmp.jpg" alt="img"> </p>
<h5 id="10-2-2-二叉树的遍历"><a href="#10-2-2-二叉树的遍历" class="headerlink" title="10.2.2 二叉树的遍历"></a>10.2.2 二叉树的遍历</h5><p>可以使用前序，中序，后序对下面的二叉树进行遍历</p>
<ol>
<li><p>前序遍历：先输出父结点，再遍历左子树和右子树</p>
</li>
<li><p>中序遍历：先遍历左子树，再遍历父结点，再遍历右子树</p>
</li>
<li><p>后序遍历：先遍历左子树，再遍历右子树，最后遍历父结点</p>
</li>
</ol>
<p>结论：看父结点输出顺序即是某序遍历</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BinaryTreeDemo &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;先需要创建一颗二叉树
        BinaryTree binaryTree &#x3D; new BinaryTree();
        &#x2F;&#x2F;创建需要的结点
        HeroNode root &#x3D; new HeroNode(1, &quot;宋江&quot;);
        HeroNode node2 &#x3D; new HeroNode(2, &quot;吴用&quot;);
        HeroNode node3 &#x3D; new HeroNode(3, &quot;卢俊义&quot;);
        HeroNode node4 &#x3D; new HeroNode(4, &quot;林冲&quot;);
        HeroNode node5 &#x3D; new HeroNode(5, &quot;关胜&quot;);

        &#x2F;&#x2F;说明，先手动创建该二叉树，后面用递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);

        System.out.println(&quot;前序遍历：&quot;);
        binaryTree.preOrder();

        System.out.println(&quot;中序遍历：&quot;);
        binaryTree.infixOrder();

        System.out.println(&quot;后序遍历：&quot;);
        binaryTree.postOrder();
    &#125;
&#125;

&#x2F;&#x2F;定义BinaryTree 二叉树
class BinaryTree&#123;
    private HeroNode root;

    public void setRoot(HeroNode root) &#123;
        this.root &#x3D; root;
    &#125;

    &#x2F;&#x2F;前序遍历
    public void preOrder()&#123;
        if (this.root !&#x3D; null)&#123;
            this.root.preOrder();
        &#125;else&#123;
            System.out.println(&quot;二叉树为空，无法遍历&quot;);
        &#125;
    &#125;

    &#x2F;&#x2F;中序遍历
    public void infixOrder()&#123;
        if (this.root !&#x3D; null)&#123;
            this.root.infixOrder();
        &#125;else&#123;
            System.out.println(&quot;二叉树为空，无法遍历&quot;);
        &#125;
    &#125;

    &#x2F;&#x2F;后序遍历
    public void postOrder()&#123;
        if (this.root !&#x3D; null)&#123;
            this.root.postOrder();
        &#125;else&#123;
            System.out.println(&quot;二叉树为空，无法遍历&quot;);
        &#125;
    &#125;
&#125;

class HeroNode&#123;
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int no, String name) &#123;
        this.no &#x3D; no;
        this.name &#x3D; name;
    &#125;

    public int getNo() &#123;
        return no;
    &#125;

    public void setNo(int no) &#123;
        this.no &#x3D; no;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name &#x3D; name;
    &#125;

    public HeroNode getLeft() &#123;
        return left;
    &#125;

    public void setLeft(HeroNode left) &#123;
        this.left &#x3D; left;
    &#125;

    public HeroNode getRight() &#123;
        return right;
    &#125;

    public void setRight(HeroNode right) &#123;
        this.right &#x3D; right;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;HeroNode&#123;&quot; +
                &quot;no&#x3D;&quot; + no +
                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

    &#x2F;&#x2F;前序遍历
    public void preOrder()&#123;
        System.out.println(this);  &#x2F;&#x2F;先输出父节点
        &#x2F;&#x2F;递归向左子树前序遍历
        if (this.left !&#x3D; null)&#123;
            this.left.preOrder();
        &#125;
        &#x2F;&#x2F;递归向右子树前序遍历
        if (this.right !&#x3D; null)&#123;
            this.right.preOrder();
        &#125;
    &#125;

    &#x2F;&#x2F;中序遍历
    public void infixOrder()&#123;
        &#x2F;&#x2F;递归向左子树前序遍历
        if (this.left !&#x3D; null)&#123;
            this.left.infixOrder();
        &#125;
        System.out.println(this);  &#x2F;&#x2F;输出父节点
        &#x2F;&#x2F;递归向右子树前序遍历
        if (this.right !&#x3D; null)&#123;
            this.right.infixOrder();
        &#125;
    &#125;

    &#x2F;&#x2F;后序遍历
    public void postOrder()&#123;

        &#x2F;&#x2F;递归向左子树前序遍历
        if (this.left !&#x3D; null)&#123;
            this.left.postOrder();
        &#125;
        &#x2F;&#x2F;递归向右子树前序遍历
        if (this.right !&#x3D; null)&#123;
            this.right.postOrder();
        &#125;
        System.out.println(this);  &#x2F;&#x2F;输出父节点
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="10-2-3-查找指定节点"><a href="#10-2-3-查找指定节点" class="headerlink" title="10.2.3 查找指定节点"></a>10.2.3 查找指定节点</h5><p>根据后序，中序，前序来进行查找</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1645865870408.png" alt="1645865870408"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BinaryTreeDemo &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;先需要创建一颗二叉树
        BinaryTree binaryTree &#x3D; new BinaryTree();
        &#x2F;&#x2F;创建需要的结点
        HeroNode root &#x3D; new HeroNode(1, &quot;宋江&quot;);
        HeroNode node2 &#x3D; new HeroNode(2, &quot;吴用&quot;);
        HeroNode node3 &#x3D; new HeroNode(3, &quot;卢俊义&quot;);
        HeroNode node4 &#x3D; new HeroNode(4, &quot;林冲&quot;);
        HeroNode node5 &#x3D; new HeroNode(5, &quot;关胜&quot;);

        &#x2F;&#x2F;说明，先手动创建该二叉树，后面用递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);

        &#x2F;&#x2F;前序遍历
        &#x2F;&#x2F;前序遍历的次数 ：4
&#x2F;&#x2F;		System.out.println(&quot;前序遍历方式~~~&quot;);
&#x2F;&#x2F;		HeroNode resNode &#x3D; binaryTree.preOrderSearch(5);
&#x2F;&#x2F;		if (resNode !&#x3D; null) &#123;
&#x2F;&#x2F;			System.out.printf(&quot;找到了，信息为 no&#x3D;%d name&#x3D;%s&quot;, resNode.getNo(), resNode.getName());
&#x2F;&#x2F;		&#125; else &#123;
&#x2F;&#x2F;			System.out.printf(&quot;没有找到 no &#x3D; %d 的英雄&quot;, 5);
&#x2F;&#x2F;		&#125;

        &#x2F;&#x2F;中序遍历查找
        &#x2F;&#x2F;中序遍历3次
&#x2F;&#x2F;		System.out.println(&quot;中序遍历方式~~~&quot;);
&#x2F;&#x2F;		HeroNode resNode &#x3D; binaryTree.infixOrderSearch(5);
&#x2F;&#x2F;		if (resNode !&#x3D; null) &#123;
&#x2F;&#x2F;			System.out.printf(&quot;找到了，信息为 no&#x3D;%d name&#x3D;%s&quot;, resNode.getNo(), resNode.getName());
&#x2F;&#x2F;		&#125; else &#123;
&#x2F;&#x2F;			System.out.printf(&quot;没有找到 no &#x3D; %d 的英雄&quot;, 5);
&#x2F;&#x2F;		&#125;

        &#x2F;&#x2F;后序遍历查找
        &#x2F;&#x2F;后序遍历查找的次数  2次
        System.out.println(&quot;后序遍历方式~~~&quot;);
        HeroNode resNode &#x3D; binaryTree.postOrderSearch(5);
        if (resNode !&#x3D; null) &#123;
            System.out.printf(&quot;找到了，信息为 no&#x3D;%d name&#x3D;%s&quot;, resNode.getNo(), resNode.getName());
        &#125; else &#123;
            System.out.printf(&quot;没有找到 no &#x3D; %d 的英雄&quot;, 5);
        &#125;
    &#125;
&#125;

&#x2F;&#x2F;定义BinaryTree 二叉树
class BinaryTree&#123;
    private HeroNode root;

    public void setRoot(HeroNode root) &#123;
        this.root &#x3D; root;
    &#125;

    &#x2F;&#x2F;前序遍历
    public HeroNode preOrderSearch(int no) &#123;
        if(root !&#x3D; null) &#123;
            return root.preOrderSearch(no);
        &#125; else &#123;
            return null;
        &#125;
    &#125;
    &#x2F;&#x2F;中序遍历
    public HeroNode infixOrderSearch(int no) &#123;
        if(root !&#x3D; null) &#123;
            return root.infixOrderSearch(no);
        &#125;else &#123;
            return null;
        &#125;
    &#125;
    &#x2F;&#x2F;后序遍历
    public HeroNode postOrderSearch(int no) &#123;
        if(root !&#x3D; null) &#123;
            return this.root.postOrderSearch(no);
        &#125;else &#123;
            return null;
        &#125;
    &#125;
&#125;

class HeroNode&#123;
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int no, String name) &#123;
        this.no &#x3D; no;
        this.name &#x3D; name;
    &#125;

    public int getNo() &#123;
        return no;
    &#125;

    public void setNo(int no) &#123;
        this.no &#x3D; no;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name &#x3D; name;
    &#125;

    public HeroNode getLeft() &#123;
        return left;
    &#125;

    public void setLeft(HeroNode left) &#123;
        this.left &#x3D; left;
    &#125;

    public HeroNode getRight() &#123;
        return right;
    &#125;

    public void setRight(HeroNode right) &#123;
        this.right &#x3D; right;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;HeroNode&#123;&quot; +
                &quot;no&#x3D;&quot; + no +
                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

    &#x2F;&#x2F;前序遍历查找
    &#x2F;**
     *
     * @param no 查找no
     * @return 如果找到就返回该Node ,如果没有找到返回 null
     *&#x2F;
    public HeroNode preOrderSearch(int no) &#123;
        System.out.println(&quot;进入前序遍历&quot;);
        &#x2F;&#x2F;比较当前结点是不是
        if(this.no &#x3D;&#x3D; no) &#123;
            return this;
        &#125;
        &#x2F;&#x2F;1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找
        &#x2F;&#x2F;2.如果左递归前序查找，找到结点，则返回
        HeroNode resNode &#x3D; null;
        if(this.left !&#x3D; null) &#123;
            resNode &#x3D; this.left.preOrderSearch(no);
        &#125;
        if(resNode !&#x3D; null) &#123;&#x2F;&#x2F;说明我们左子树找到
            return resNode;
        &#125;
        &#x2F;&#x2F;1.左递归前序查找，找到结点，则返回，否继续判断，
        &#x2F;&#x2F;2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找
        if(this.right !&#x3D; null) &#123;
            resNode &#x3D; this.right.preOrderSearch(no);
        &#125;
        return resNode;
    &#125;

    &#x2F;&#x2F;中序遍历查找
    public HeroNode infixOrderSearch(int no) &#123;
        &#x2F;&#x2F;判断当前结点的左子节点是否为空，如果不为空，则递归中序查找
        HeroNode resNode &#x3D; null;
        if(this.left !&#x3D; null) &#123;
            resNode &#x3D; this.left.infixOrderSearch(no);
        &#125;
        if(resNode !&#x3D; null) &#123;
            return resNode;
        &#125;
        System.out.println(&quot;进入中序查找&quot;);
        &#x2F;&#x2F;如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点
        if(this.no &#x3D;&#x3D; no) &#123;
            return this;
        &#125;
        &#x2F;&#x2F;否则继续进行右递归的中序查找
        if(this.right !&#x3D; null) &#123;
            resNode &#x3D; this.right.infixOrderSearch(no);
        &#125;
        return resNode;

    &#125;

    &#x2F;&#x2F;后序遍历查找
    public HeroNode postOrderSearch(int no) &#123;

        &#x2F;&#x2F;判断当前结点的左子节点是否为空，如果不为空，则递归后序查找
        HeroNode resNode &#x3D; null;
        if(this.left !&#x3D; null) &#123;
            resNode &#x3D; this.left.postOrderSearch(no);
        &#125;
        if(resNode !&#x3D; null) &#123;&#x2F;&#x2F;说明在左子树找到
            return resNode;
        &#125;

        &#x2F;&#x2F;如果左子树没有找到，则向右子树递归进行后序遍历查找
        if(this.right !&#x3D; null) &#123;
            resNode &#x3D; this.right.postOrderSearch(no);
        &#125;
        if(resNode !&#x3D; null) &#123;
            return resNode;
        &#125;
        System.out.println(&quot;进入后序查找&quot;);
        &#x2F;&#x2F;如果左右子树都没有找到，就比较当前结点是不是
        if(this.no &#x3D;&#x3D; no) &#123;
            return this;
        &#125;
        return resNode;
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="10-2-4-删除指定节点"><a href="#10-2-4-删除指定节点" class="headerlink" title="10.2.4 删除指定节点"></a>10.2.4 删除指定节点</h5><p>递归删除结点：<br>    1. 如果删除的节点是叶子节点，则删除该节点<br>        2. 如果删除的节点是非叶子节点，则删除该子树</p>
<p>思路：</p>
<ol>
<li>因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.<ol start="2">
<li>如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left &#x3D; null; 并且就返回(结束递归删除)</li>
<li>如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right&#x3D; null ;并且就返回(结束递归删除)</li>
<li>如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</li>
<li>如果第4步也没有删除结点，则应当向右子树进行递归删除.</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BinaryTreeDemo &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;先需要创建一颗二叉树
        BinaryTree binaryTree &#x3D; new BinaryTree();
        &#x2F;&#x2F;创建需要的结点
        HeroNode root &#x3D; new HeroNode(1, &quot;宋江&quot;);
        HeroNode node2 &#x3D; new HeroNode(2, &quot;吴用&quot;);
        HeroNode node3 &#x3D; new HeroNode(3, &quot;卢俊义&quot;);
        HeroNode node4 &#x3D; new HeroNode(4, &quot;林冲&quot;);
        HeroNode node5 &#x3D; new HeroNode(5, &quot;关胜&quot;);

        &#x2F;&#x2F;说明，先手动创建该二叉树，后面用递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);

        &#x2F;&#x2F;测试删除结点
        System.out.println(&quot;删除前,前序遍历&quot;);
        binaryTree.preOrder(); &#x2F;&#x2F;  1,2,3,5,4
        binaryTree.delNode(5);
        &#x2F;&#x2F;binaryTree.delNode(3);
        System.out.println(&quot;删除后，前序遍历&quot;);
        binaryTree.preOrder(); &#x2F;&#x2F; 1,2,3,4
    &#125;
&#125;

&#x2F;&#x2F;定义BinaryTree 二叉树
class BinaryTree&#123;
    private HeroNode root;

    public void setRoot(HeroNode root) &#123;
        this.root &#x3D; root;
    &#125;

    &#x2F;&#x2F;删除结点
    public void delNode(int no) &#123;
        if(root !&#x3D; null) &#123;
            &#x2F;&#x2F;如果只有一个root结点, 这里立即判断root是不是就是要删除结点
            if(root.getNo() &#x3D;&#x3D; no) &#123;
                root &#x3D; null;
            &#125; else &#123;
                &#x2F;&#x2F;递归删除
                root.delNode(no);
            &#125;
        &#125;else&#123;
            System.out.println(&quot;这是一个空树！不能删除！&quot;);
        &#125;
    &#125;
&#125;

class HeroNode&#123;
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int no, String name) &#123;
        this.no &#x3D; no;
        this.name &#x3D; name;
    &#125;

    public int getNo() &#123;
        return no;
    &#125;

    public void setNo(int no) &#123;
        this.no &#x3D; no;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name &#x3D; name;
    &#125;

    public HeroNode getLeft() &#123;
        return left;
    &#125;

    public void setLeft(HeroNode left) &#123;
        this.left &#x3D; left;
    &#125;

    public HeroNode getRight() &#123;
        return right;
    &#125;

    public void setRight(HeroNode right) &#123;
        this.right &#x3D; right;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;HeroNode&#123;&quot; +
                &quot;no&#x3D;&quot; + no +
                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

    &#x2F;&#x2F;递归删除结点
    public void delNode(int no) &#123;
        
        &#x2F;&#x2F;2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left &#x3D; null; 并且就返回(结束递归删除)
        if(this.left !&#x3D; null &amp;&amp; this.left.no &#x3D;&#x3D; no) &#123;
            this.left &#x3D; null;
            return;
        &#125;
        &#x2F;&#x2F;3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right&#x3D; null ;并且就返回(结束递归删除)
        if(this.right !&#x3D; null &amp;&amp; this.right.no &#x3D;&#x3D; no) &#123;
            this.right &#x3D; null;
            return;
        &#125;
        &#x2F;&#x2F;4.我们就需要向左子树进行递归删除
        if(this.left !&#x3D; null) &#123;
            this.left.delNode(no);
        &#125;
        &#x2F;&#x2F;5.则应当向右子树进行递归删除
        if(this.right !&#x3D; null) &#123;
            this.right.delNode(no);
        &#125;
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="10-3-顺序存储二叉树"><a href="#10-3-顺序存储二叉树" class="headerlink" title="10.3 顺序存储二叉树"></a>10.3 顺序存储二叉树</h4><h5 id="10-3-1-概述"><a href="#10-3-1-概述" class="headerlink" title="10.3.1 概述"></a>10.3.1 概述</h5><p>二叉树的顺序存储就是用一组连续的存储单元（数组）存放二又树中的结点元素，一般按照二叉树结点自上向下、自左向右的顺序存储。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps792.tmp.jpg" alt="img"> </p>
<p>顺序存储二叉树特点：</p>
<ol>
<li><p>顺序二叉树通常只考虑完全二叉树</p>
</li>
<li><p>第n个元素的左子结点为2*n+1</p>
</li>
<li><p>第n个元素的右子结点为2*n+2</p>
</li>
<li><p>第n个元素的父结点为（n-1）&#x2F;2</p>
</li>
<li><p>n表示二叉树中第几个元素，按编号从0开始</p>
</li>
</ol>
<h5 id="10-3-2-实现"><a href="#10-3-2-实现" class="headerlink" title="10.3.2 实现"></a>10.3.2 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrBinaryTreeDemo &#123;
    public static void main(String[] args) &#123;
        int[] arr &#x3D; &#123;1,2,3,4,5,6,7&#125;;
        &#x2F;&#x2F;创建一个 ArrBinaryTree
        ArrBinaryTree arrBinaryTree &#x3D; new ArrBinaryTree(arr);
        arrBinaryTree.preOrder(0);
    &#125;
&#125;

&#x2F;&#x2F;编写一个ArrayBinaryTree, 实现顺序存储二叉树遍历
class ArrBinaryTree&#123;
    private int[] arr;  &#x2F;&#x2F;存储数据结点的数组

    public ArrBinaryTree(int[] arr) &#123;
        this.arr &#x3D; arr;
    &#125;

    &#x2F;&#x2F;重载preOrder
    public void preOrder() &#123;
        this.preOrder(0);
    &#125;

    &#x2F;&#x2F;编写一个方法，完成顺序存储二叉树的前序遍历
    &#x2F;**
     *
     * @param index 数组的下标
     *&#x2F;
    public void preOrder(int index) &#123;
        &#x2F;&#x2F;如果数组为空，或者 arr.length &#x3D; 0
        if(arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0) &#123;
            System.out.println(&quot;数组为空，不能按照二叉树的前序遍历&quot;);
        &#125;
        &#x2F;&#x2F;输出当前这个元素
        System.out.println(arr[index]);
        &#x2F;&#x2F;向左递归遍历
        if((index * 2 + 1) &lt; arr.length) &#123;
            preOrder(2 * index + 1 );
        &#125;
        &#x2F;&#x2F;向右递归遍历
        if((index * 2 + 2) &lt; arr.length) &#123;
            preOrder(2 * index + 2);
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="10-4-线索二叉树"><a href="#10-4-线索二叉树" class="headerlink" title="10.4 线索二叉树"></a>10.4 线索二叉树</h4><h5 id="10-4-1-概述"><a href="#10-4-1-概述" class="headerlink" title="10.4.1 概述"></a>10.4.1 概述</h5><p>​    在二叉树的结点上加上线索的二叉树称为线索二叉树，对二叉树以某种遍历方式（如先序、中序、后序等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。</p>
<ol>
<li>n个结点的二叉链表中含有n+1  【公式 2n-(n-1)&#x3D;n+1】 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）</li>
<li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</li>
<li>一个结点的前一个结点，称为<strong>前驱结点</strong>；一个结点的后一个结点，称为<strong>后继结点</strong></li>
</ol>
<h5 id="10-4-2-实现"><a href="#10-4-2-实现" class="headerlink" title="10.4.2 实现"></a>10.4.2 实现</h5><p>将下面的二叉树，进行<strong>中序线索二叉树</strong>。中序遍历的数列为 {8, 3, 10, 1, 14, 6}</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646044571730.png" alt="1646044571730"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package threadedBinaryTreeDemo;

public class ThreadedBinaryTreeDemo &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;测试一把中序线索二叉树的功能
        HeroNode root &#x3D; new HeroNode(1, &quot;tom&quot;);
        HeroNode node2 &#x3D; new HeroNode(3, &quot;jack&quot;);
        HeroNode node3 &#x3D; new HeroNode(6, &quot;smith&quot;);
        HeroNode node4 &#x3D; new HeroNode(8, &quot;mary&quot;);
        HeroNode node5 &#x3D; new HeroNode(10, &quot;king&quot;);
        HeroNode node6 &#x3D; new HeroNode(14, &quot;dim&quot;);

        &#x2F;&#x2F;二叉树，后面我们要递归创建, 现在简单处理使用手动创建
        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);

        &#x2F;&#x2F;测试中序线索化
        ThreadedBinaryTree threadedBinaryTree &#x3D; new ThreadedBinaryTree();
        threadedBinaryTree.setRoot(root);
        threadedBinaryTree.threadedNodes();

        &#x2F;&#x2F;测试: 以10号节点测试
        HeroNode leftNode &#x3D; node5.getLeft();
        HeroNode rightNode &#x3D; node5.getRight();
        System.out.println(&quot;10号结点的前驱结点是&#x3D;&quot;  + leftNode); &#x2F;&#x2F;3
        System.out.println(&quot;10号结点的后继结点是&#x3D;&quot;  + rightNode); &#x2F;&#x2F;1

        &#x2F;&#x2F;当线索化二叉树后，能在使用原来的遍历方法
        System.out.println(&quot;使用线索化的方式遍历 线索化二叉树&quot;);
        threadedBinaryTree.threadedList(); &#x2F;&#x2F; 8, 3, 10, 1, 14, 6
    &#125;
&#125;

&#x2F;&#x2F;定义BinaryTree 二叉树
class ThreadedBinaryTree &#123;
    private HeroNode root;

    &#x2F;&#x2F;为了实现线索化，需要创建要给指向当前结点的前驱结点的指针&#x2F;&#x2F;为了实现线索化，需要创建要给指向当前结点的前驱结点的指针
    &#x2F;&#x2F;在递归进行线索化时，pre 总是保留前一个结点
    private HeroNode pre &#x3D; null;

    public void setRoot(HeroNode root) &#123;
        this.root &#x3D; root;
    &#125;

    &#x2F;&#x2F;重载一把threadedNodes方法
    public void threadedNodes() &#123;
        this.threadedNodes(root);
    &#125;

    &#x2F;&#x2F;遍历线索化二叉树的方法
    public void threadedList() &#123;
        &#x2F;&#x2F;定义一个变量，存储当前遍历的结点，从root开始
        HeroNode node &#x3D; root;
        while(node !&#x3D; null) &#123;
            &#x2F;&#x2F;循环的找到leftType &#x3D;&#x3D; 1的结点，第一个找到就是8结点
            &#x2F;&#x2F;后面随着遍历而变化,因为当leftType&#x3D;&#x3D;1时，说明该结点是按照线索化
            &#x2F;&#x2F;处理后的有效结点
            while(node.getLeftType() &#x3D;&#x3D; 0) &#123;
                node &#x3D; node.getLeft();
            &#125;

            &#x2F;&#x2F;打印当前这个结点
            System.out.println(node);
            &#x2F;&#x2F;如果当前结点的右指针指向的是后继结点,就一直输出
            while(node.getRightType() &#x3D;&#x3D; 1) &#123;
                &#x2F;&#x2F;获取到当前结点的后继结点
                node &#x3D; node.getRight();
                System.out.println(node);
            &#125;
            &#x2F;&#x2F;替换这个遍历的结点
            node &#x3D; node.getRight();
        &#125;
    &#125;

    &#x2F;&#x2F;编写对二叉树进行中序线索化的方法
    &#x2F;**
     *
     * @param node 就是当前需要线索化的结点
     *&#x2F;
    public void threadedNodes(HeroNode node) &#123;

        &#x2F;&#x2F;如果node&#x3D;&#x3D;null, 不能线索化
        if(node &#x3D;&#x3D; null) &#123;
            return;
        &#125;

        &#x2F;&#x2F;(一)先线索化左子树
        threadedNodes(node.getLeft());
        &#x2F;&#x2F;(二)线索化当前结点[有难度]

        &#x2F;&#x2F;处理当前结点的前驱结点
        &#x2F;&#x2F;以8结点来理解
        &#x2F;&#x2F;8结点的.left &#x3D; null , 8结点的.leftType &#x3D; 1
        if(node.getLeft() &#x3D;&#x3D; null) &#123;
            &#x2F;&#x2F;让当前结点的左指针指向前驱结点
            node.setLeft(pre);
            &#x2F;&#x2F;修改当前结点的左指针的类型,指向前驱结点
            node.setLeftType(1);
        &#125;

        &#x2F;&#x2F;处理后继结点
        if (pre !&#x3D; null &amp;&amp; pre.getRight() &#x3D;&#x3D; null) &#123;
            &#x2F;&#x2F;让前驱结点的右指针指向当前结点
            pre.setRight(node);
            &#x2F;&#x2F;修改前驱结点的右指针类型
            pre.setRightType(1);
        &#125;
        &#x2F;&#x2F;!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点
        pre &#x3D; node;

        &#x2F;&#x2F;(三)在线索化右子树
        threadedNodes(node.getRight());
    &#125;
&#125;

class HeroNode &#123;
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;&#x2F;&#x2F;说明
    &#x2F;&#x2F;1. 如果leftType &#x3D;&#x3D; 0 表示指向的是左子树, 如果 1 则表示指向前驱结点
    &#x2F;&#x2F;2. 如果rightType &#x3D;&#x3D; 0 表示指向是右子树, 如果 1表示指向后继结点
    private int leftType;
    private int rightType;


    public HeroNode(int no, String name) &#123;
        this.no &#x3D; no;
        this.name &#x3D; name;
    &#125;

    public int getNo() &#123;
        return no;
    &#125;

    public void setNo(int no) &#123;
        this.no &#x3D; no;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name &#x3D; name;
    &#125;

    public HeroNode getLeft() &#123;
        return left;
    &#125;

    public void setLeft(HeroNode left) &#123;
        this.left &#x3D; left;
    &#125;

    public HeroNode getRight() &#123;
        return right;
    &#125;

    public void setRight(HeroNode right) &#123;
        this.right &#x3D; right;
    &#125;

    public int getLeftType() &#123;
        return leftType;
    &#125;

    public void setLeftType(int leftType) &#123;
        this.leftType &#x3D; leftType;
    &#125;

    public int getRightType() &#123;
        return rightType;
    &#125;

    public void setRightType(int rightType) &#123;
        this.rightType &#x3D; rightType;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;HeroNode&#123;&quot; +
                &quot;no&#x3D;&quot; + no +
                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="11-树结构实际应用"><a href="#11-树结构实际应用" class="headerlink" title="11 树结构实际应用"></a>11 树结构实际应用</h3><h4 id="11-1-堆排序"><a href="#11-1-堆排序" class="headerlink" title="11.1 堆排序"></a>11.1 堆排序</h4><h5 id="11-1-1-概述"><a href="#11-1-1-概述" class="headerlink" title="11.1.1 概述"></a>11.1.1 概述</h5><ol>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p>
</li>
<li><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。</p>
</li>
<li><p>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
</li>
<li><p>大顶堆举例说明：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646063403656.png" alt="1646063403656"></p>
</li>
</ol>
<p>我们对堆中的结点按层进行编号，映射到数组中就是下面这个样子:<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646063447572.png" alt="1646063447572"><br>大顶堆特点：arr[i] &gt;&#x3D; arr[2<em>i+1] &amp;&amp; arr[i] &gt;&#x3D; arr[2</em>i+2]  &#x2F;&#x2F; i 对应第几个节点，i从0开始编号</p>
<ol start="5">
<li><p>小顶堆举例说明：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646063547888.png" alt="1646063547888"></p>
<p>小顶堆：arr[i] &lt;&#x3D; arr[2<em>i+1] &amp;&amp; arr[i] &lt;&#x3D; arr[2</em>i+2] &#x2F;&#x2F; i 对应第几个节点，i从0开始编号。</p>
</li>
<li><p>一般升序采用大顶堆，降序采用小顶堆。</p>
</li>
</ol>
<h5 id="11-1-2-思想"><a href="#11-1-2-思想" class="headerlink" title="11.1.2 思想"></a>11.1.2 思想</h5><p>堆排序的基本思想是：</p>
<ol>
<li><p>将待排序序列构造成一个大顶堆</p>
</li>
<li><p>此时，整个序列的最大值就是堆顶的根节点。</p>
</li>
<li><p>将其与末尾元素进行交换，此时末尾就为最大值。</p>
</li>
<li><p>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p>
</li>
</ol>
<p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p>
<h5 id="11-1-3-实现"><a href="#11-1-3-实现" class="headerlink" title="11.1.3 实现"></a>11.1.3 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;

public class HeapSort &#123;

    public static void main(String[] args) &#123;
        &#x2F;&#x2F;要求将数组进行升序排序
        int arr[] &#x3D; &#123;4, 6, 8, 5, 9&#125;;
        heapSort(arr);
    &#125;

    &#x2F;&#x2F;编写一个堆排序的方法
    public static void heapSort(int arr[]) &#123;
        int temp &#x3D; 0;
        System.out.println(&quot;堆排序!!&quot;);

        &#x2F;&#x2F;将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
        for(int i &#x3D; arr.length &#x2F; 2 -1; i &gt;&#x3D;0; i--) &#123;
            adjustHeap(arr, i, arr.length);
        &#125;

		&#x2F;*
		 * 2).将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;
　　			3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
		 *&#x2F;
        for(int j &#x3D; arr.length-1;j &gt;0; j--) &#123;
            &#x2F;&#x2F;交换
            temp &#x3D; arr[j];
            arr[j] &#x3D; arr[0];
            arr[0] &#x3D; temp;
            adjustHeap(arr, 0, j);
        &#125;

        System.out.println(&quot;数组&#x3D;&quot; + Arrays.toString(arr));
    &#125;

    &#x2F;&#x2F;将一个数组(二叉树), 调整成一个大顶堆
    &#x2F;**
     * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆
     * 举例  int arr[] &#x3D; &#123;4, 6, 8, 5, 9&#125;; &#x3D;&gt; i &#x3D; 1 &#x3D;&gt; adjustHeap &#x3D;&gt; 得到 &#123;4, 9, 8, 5, 6&#125;
     * 如果我们再次调用  adjustHeap 传入的是 i &#x3D; 0 &#x3D;&gt; 得到 &#123;4, 9, 8, 5, 6&#125; &#x3D;&gt; &#123;9,6,8,5, 4&#125;
     * @param arr 待调整的数组
     * @param i 表示非叶子结点在数组中索引
     * @param lenght 表示对多少个元素继续调整， length 是在逐渐的减少
     *&#x2F;
    public  static void adjustHeap(int arr[], int i, int lenght) &#123;

        int temp &#x3D; arr[i];&#x2F;&#x2F;先取出当前元素的值，保存在临时变量
        &#x2F;&#x2F;开始调整
        &#x2F;&#x2F;说明
        &#x2F;&#x2F;1. k &#x3D; i * 2 + 1 k 是 i结点的左子结点
        for(int k &#x3D; i * 2 + 1; k &lt; lenght; k &#x3D; k * 2 + 1) &#123;
            if(k+1 &lt; lenght &amp;&amp; arr[k] &lt; arr[k+1]) &#123; &#x2F;&#x2F;说明左子结点的值小于右子结点的值
                k++; &#x2F;&#x2F; k 指向右子结点
            &#125;
            if(arr[k] &gt; temp) &#123; &#x2F;&#x2F;如果子结点大于父结点
                arr[i] &#x3D; arr[k]; &#x2F;&#x2F;把较大的值赋给当前结点
                i &#x3D; k; &#x2F;&#x2F;!!! i 指向 k,继续循环比较
            &#125; else &#123;
                break;&#x2F;&#x2F;!
            &#125;
        &#125;
        &#x2F;&#x2F;当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)
        arr[i] &#x3D; temp;&#x2F;&#x2F;将temp值放到调整后的位置
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="11-2-赫夫曼树"><a href="#11-2-赫夫曼树" class="headerlink" title="11.2 赫夫曼树"></a>11.2 赫夫曼树</h4><h5 id="11-2-1-概述"><a href="#11-2-1-概述" class="headerlink" title="11.2.1 概述"></a>11.2.1 概述</h5><p>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</p>
<p>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
<ul>
<li><p>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。</p>
</li>
<li><p>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。</p>
</li>
<li><p>树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</p>
</li>
<li><p>WPL最小的就是赫夫曼树。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646124809558.png" alt="1646124809558"></p>
</li>
</ul>
<h5 id="11-2-2-思想"><a href="#11-2-2-思想" class="headerlink" title="11.2.2 思想"></a>11.2.2 思想</h5><p>构成赫夫曼树的步骤：</p>
<ol>
<li><p>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树。</p>
</li>
<li><p>取出根节点权值最小的两颗二叉树 </p>
</li>
<li><p>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和。</p>
</li>
<li><p>再将这颗新的二叉树，以根节点的权值大小 再次排序。</p>
</li>
<li><p>不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p>
</li>
</ol>
<h5 id="11-2-3-实现"><a href="#11-2-3-实现" class="headerlink" title="11.2.3 实现"></a>11.2.3 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;

public class HuffmanTree &#123;

    public static void main(String[] args) &#123;
        int arr[] &#x3D; &#123; 13, 7, 8, 3, 29, 6, 1 &#125;;
        Node root &#x3D; createHuffmanTree(arr);

        preOrder(root);

    &#125;

    &#x2F;&#x2F;编写一个前序遍历的方法
    public static void preOrder(Node root) &#123;
        if(root !&#x3D; null) &#123;
            root.preOrder();
        &#125;else&#123;
            System.out.println(&quot;是空树，不能遍历~~&quot;);
        &#125;
    &#125;

    &#x2F;&#x2F; 创建赫夫曼树的方法
    &#x2F;**
     *
     * @param arr 需要创建成哈夫曼树的数组
     * @return 创建好后的赫夫曼树的root结点
     *&#x2F;
    public static Node createHuffmanTree(int[] arr) &#123;
        &#x2F;&#x2F; 第一步为了操作方便
        &#x2F;&#x2F; 1. 遍历 arr 数组
        &#x2F;&#x2F; 2. 将arr的每个元素构成成一个Node
        &#x2F;&#x2F; 3. 将Node 放入到ArrayList中
        List&lt;Node&gt; nodes &#x3D; new ArrayList&lt;Node&gt;();
        for (int value : arr) &#123;
            nodes.add(new Node(value));
        &#125;

        while(nodes.size() &gt; 1) &#123;

            &#x2F;&#x2F;排序 从小到大
            Collections.sort(nodes);

            System.out.println(&quot;nodes &#x3D;&quot; + nodes);

            &#x2F;&#x2F;取出根节点权值最小的两颗二叉树
            &#x2F;&#x2F;(1) 取出权值最小的结点（二叉树）
            Node leftNode &#x3D; nodes.get(0);
            &#x2F;&#x2F;(2) 取出权值第二小的结点（二叉树）
            Node rightNode &#x3D; nodes.get(1);

            &#x2F;&#x2F;(3)构建一颗新的二叉树
            Node parent &#x3D; new Node(leftNode.value + rightNode.value);
            parent.left &#x3D; leftNode;
            parent.right &#x3D; rightNode;

            &#x2F;&#x2F;(4)从ArrayList删除处理过的二叉树
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            &#x2F;&#x2F;(5)将parent加入到nodes
            nodes.add(parent);
        &#125;

        &#x2F;&#x2F;返回哈夫曼树的root结点
        return nodes.get(0);

    &#125;
&#125;

&#x2F;&#x2F; 创建结点类
&#x2F;&#x2F; 为了让Node 对象持续排序Collections集合排序
&#x2F;&#x2F; 让Node 实现Comparable接口
class Node implements Comparable&lt;Node&gt; &#123;
    int value; &#x2F;&#x2F; 结点权值
    Node left; &#x2F;&#x2F; 指向左子结点
    Node right; &#x2F;&#x2F; 指向右子结点

    &#x2F;&#x2F;写一个前序遍历
    public void preOrder() &#123;
        System.out.println(this);
        if(this.left !&#x3D; null) &#123;
            this.left.preOrder();
        &#125;
        if(this.right !&#x3D; null) &#123;
            this.right.preOrder();
        &#125;
    &#125;

    public Node(int value) &#123;
        this.value &#x3D; value;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Node [value&#x3D;&quot; + value + &quot;]&quot;;
    &#125;

    @Override
    public int compareTo(Node o) &#123;
        &#x2F;&#x2F; TODO Auto-generated method stub
        &#x2F;&#x2F; 表示从小到大排序
        return this.value - o.value;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="11-3-赫夫曼编码"><a href="#11-3-赫夫曼编码" class="headerlink" title="11.3 赫夫曼编码"></a>11.3 赫夫曼编码</h4><h5 id="11-3-1-概述"><a href="#11-3-1-概述" class="headerlink" title="11.3.1 概述"></a>11.3.1 概述</h5><ul>
<li><p>赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</p>
</li>
<li><p>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</p>
</li>
<li><p>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间</p>
</li>
</ul>
<ul>
<li>赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</li>
</ul>
<h5 id="11-3-2-原理剖析"><a href="#11-3-2-原理剖析" class="headerlink" title="11.3.2 原理剖析"></a>11.3.2 原理剖析</h5><p>通信领域中信息的处理方式1-定长编码：</p>
<pre class="line-numbers language-定长编码" data-language="定长编码"><code class="language-定长编码">i like like like java do you like a java       &#x2F;&#x2F; 共40个字符(包括空格)  
105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97  &#x2F;&#x2F;对应Ascii码

01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001 &#x2F;&#x2F;对应的二进制

按照二进制来传递信息，总的长度是  359   (包括空格)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通信领域中信息的处理方式2-变长编码：</p>
<pre class="line-numbers language-变长编码" data-language="变长编码"><code class="language-变长编码">i like like like java do you like a java       &#x2F;&#x2F; 共40个字符(包括空格)

d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  &#x2F;&#x2F; 各个字符对应的个数
0&#x3D;  ,  1&#x3D;a, 10&#x3D;i, 11&#x3D;e, 100&#x3D;k, 101&#x3D;l, 110&#x3D;o, 111&#x3D;v, 1000&#x3D;j, 1001&#x3D;u, 1010&#x3D;y, 1011&#x3D;d 说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推.

按照上面给各个字符规定的编码，则我们在传输  &quot;i like like like java do you like a java&quot; 数据时，编码就是 10010110100...  
字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通信领域中信息的处理方式3-赫夫曼编码：</p>
<pre class="line-numbers language-赫夫曼编码" data-language="赫夫曼编码"><code class="language-赫夫曼编码">i like like like java do you like a java       &#x2F;&#x2F; 共40个字符(包括空格)

d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  &#x2F;&#x2F; 各个字符对应的个数
按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值.(图后)

&#x2F;&#x2F;根据赫夫曼树，给各个字符
&#x2F;&#x2F;规定编码 ， 向左的路径为0
&#x2F;&#x2F;向右的路径为1 ， 编码如下:
o: 1000   u: 10010  d: 100110  y: 100111  i: 101
a : 110     k: 1110    e: 1111       j: 0000       v: 0001
l: 001          : 01

按照上面的赫夫曼编码，我们的&quot;i like like like java do you like a java&quot;   字符串对应的编码为 (注意这里我们使用的无损压缩)

1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110

长度为 ： 133 
说明:
1.原来长度是  359 , 压缩了  (359-133) &#x2F; 359 &#x3D; 62.9%
2.此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性

注意：赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl是一样的，都是最小的。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646132349404.png" alt="1646132349404"></p>
<h4 id="11-4-二叉排序树"><a href="#11-4-二叉排序树" class="headerlink" title="11.4 二叉排序树"></a>11.4 二叉排序树</h4><h5 id="11-4-1-概述"><a href="#11-4-1-概述" class="headerlink" title="11.4.1 概述"></a>11.4.1 概述</h5><p>需求分析：</p>
<pre class="line-numbers language-需求分析" data-language="需求分析"><code class="language-需求分析">需求：
给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加。
分析：
a.使用数组：
  1.数组未排序，优点：直接在数组尾添加，速度快；缺点：查找速度慢。
  2.数组排序，优点：可以使用二分查找，查找速度快；缺点：为了保证数组有序，在添加新数据时，找到插入位置后，     后面的数据需整体移动，速度慢。

b.使用链式存储-链表：不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。

c.使用二叉排序树

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>二叉排序树</strong>：BST: (Binary Sort(Search) Tree)， 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。<br>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点</p>
<p>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646310706992.png" alt="1646310706992"></p>
<h5 id="11-4-2-二叉排序树创建和遍历"><a href="#11-4-2-二叉排序树创建和遍历" class="headerlink" title="11.4.2 二叉排序树创建和遍历"></a>11.4.2 二叉排序树创建和遍历</h5><p>一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为 Array(7, 3, 10, 12, 5, 1, 9) ， 创建成对应的二叉排序树为 :</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646311292197.png" alt="1646311292197"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public void add(Node node) &#123;
	if (node &#x3D;&#x3D; null) &#123;
		return;
	&#125;
    if (node.value &lt; this.value) &#123;
        &#x2F;&#x2F; 如果左节点为空
        if (this.left &#x3D;&#x3D; null) &#123;
        	this.left &#x3D; node;
        &#125; else &#123;&#x2F;&#x2F; 如果不为空,递归添加
        	this.left.add(node);
        &#125;
    &#125; else &#123;
    	if (this.right &#x3D;&#x3D; null) &#123;
    		this.right &#x3D; node;
    	&#125; else &#123;&#x2F;&#x2F; 如果不为空,递归添加
   			this.right.add(node);
    	&#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 向二叉排序树添加节点
public void add(Node node) &#123;
	&#x2F;&#x2F; 如果是一颗空树，则直接赋给root即可.
	if (root &#x3D;&#x3D; null) &#123;
		root &#x3D; node;
	&#125; else &#123;
		root.add(node);
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="11-4-3-二叉排序树的删除"><a href="#11-4-3-二叉排序树的删除" class="headerlink" title="11.4.3 二叉排序树的删除"></a>11.4.3 二叉排序树的删除</h5><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑：</p>
<ol>
<li>删除叶子节点 (比如：2, 5, 9, 12)</li>
<li>删除只有一颗子树的节点 (比如：1)</li>
<li>删除有两颗子树的节点. (比如：7, 3，10 )</li>
</ol>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646311577722.png" alt="1646311577722"></p>
<pre class="line-numbers language-思路" data-language="思路"><code class="language-思路">第一种情况:
删除叶子节点（比如:2,5,9,12) 思路：
(1)需求先去找到要删除的结点targetNode
(2)找到 targetNode 的父结点 parent
(3)确定targetNode是 parent的左子结点还是右子结点
(4)根据前面的情况来对应删除：
   左子结点parent.left &#x3D; null
   右子结点parent.right &#x3D; null

第二种情况:
删除只有一颗子树的节点比如1 思路：
(1)需求先去找到要删除的结点targetNode
(2)找到targetNode的父结点parent
(3)确定targetNode 的子结点是左子结点还是右子结点
(4)targetNode是 parent 的左子结点还是右子结点
(5)如果 targetNode有左子结点
	5.1如果targetNode是 parent的左子结点
		parent.left&#x3D; targetNode.left
	5.2如果 targetNode 是 parent的右子结点
		parent.right &#x3D; targetNode.left
(6)如果targetNode有右子结点
	6.1 如果targetNode是 parent的左子结点
		parent.left &#x3D; targetNode.right
	6.2如果targetNode是 parent的右子结点
		parent.right &#x3D; targetNode.right
		
第三种情况:
删除有两颗子树的节点.(比如: 7,3,10) 思路：
(1)需求先去找到要删除的结点targetNode
(2)找到 targetNode 的父结点 parent
(3)从targetNode 的右子树找到最小的结点
(4)用一个临时变量，将最小结点的值保存temp &#x3D; 11(5)删除该最小结点
(6)targetNode.value &#x3D; temp

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="11-4-4-总体实现"><a href="#11-4-4-总体实现" class="headerlink" title="11.4.4 总体实现"></a>11.4.4 总体实现</h5><pre class="line-numbers language-main" data-language="main"><code class="language-main">public class BinarySortTreeDemo &#123;
	public static void main(String[] args) &#123;
		int[] arr &#x3D; &#123;7, 3, 10, 12, 5, 1, 9, 2&#125;;
		BinarySortTree binarySortTree &#x3D; new BinarySortTree();
		&#x2F;&#x2F;循环的添加结点到二叉排序树
		for(int i &#x3D; 0; i&lt; arr.length; i++) &#123;
			binarySortTree.add(new Node(arr[i]));
		&#125;
		
		&#x2F;&#x2F;中序遍历二叉排序树
		System.out.println(&quot;中序遍历二叉排序树~&quot;);
		binarySortTree.infixOrder(); &#x2F;&#x2F; 1, 3, 5, 7, 9, 10, 12
		
		&#x2F;&#x2F;测试一下删除叶子结点	   
	    binarySortTree.delNode(12);	 
	    binarySortTree.delNode(5);
	    binarySortTree.delNode(10);
	    binarySortTree.delNode(2);
	    binarySortTree.delNode(3);
		   
	    binarySortTree.delNode(9);
	    binarySortTree.delNode(1);
	    binarySortTree.delNode(7);
	    	
		System.out.println(&quot;root&#x3D;&quot; + binarySortTree.getRoot());
		
		System.out.println(&quot;删除结点后&quot;);
		binarySortTree.infixOrder();
	&#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-BinarySortTree" data-language="BinarySortTree"><code class="language-BinarySortTree">&#x2F;&#x2F;创建二叉排序树
class BinarySortTree &#123;
	private Node root;
	
	public Node getRoot() &#123;
		return root;
	&#125;

	&#x2F;&#x2F;查找要删除的结点
	public Node search(int value) &#123;
		if(root &#x3D;&#x3D; null) &#123;
			return null;
		&#125; else &#123;
			return root.search(value);
		&#125;
	&#125;
	
	&#x2F;&#x2F;查找父结点
	public Node searchParent(int value) &#123;
		if(root &#x3D;&#x3D; null) &#123;
			return null;
		&#125; else &#123;
			return root.searchParent(value);
		&#125;
	&#125;
	
	&#x2F;&#x2F;编写方法: 
	&#x2F;&#x2F;1. 返回的 以node 为根结点的二叉排序树的最小结点的值
	&#x2F;&#x2F;2. 删除node 为根结点的二叉排序树的最小结点
	&#x2F;**
	 * 
	 * @param node 传入的结点(当做二叉排序树的根结点)
	 * @return 返回的 以node 为根结点的二叉排序树的最小结点的值
	 *&#x2F;
	public int delRightTreeMin(Node node) &#123;
		Node target &#x3D; node;
		&#x2F;&#x2F;循环的查找左子节点，就会找到最小值
		while(target.left !&#x3D; null) &#123;
			target &#x3D; target.left;
		&#125;
		&#x2F;&#x2F;这时 target就指向了最小结点
		&#x2F;&#x2F;删除最小结点
		delNode(target.value);
		return target.value;
	&#125;
	
	&#x2F;&#x2F;删除结点
	public void delNode(int value) &#123;
		if(root &#x3D;&#x3D; null) &#123;
			return;
		&#125;else &#123;
			&#x2F;&#x2F;1.需求先去找到要删除的结点  targetNode
			Node targetNode &#x3D; search(value);
			&#x2F;&#x2F;如果没有找到要删除的结点
			if(targetNode &#x3D;&#x3D; null) &#123;
				return;
			&#125;
			&#x2F;&#x2F;如果我们发现当前这颗二叉排序树只有一个结点
			if(root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;
				root &#x3D; null;
				return;
			&#125;
			
			&#x2F;&#x2F;去找到targetNode的父结点
			Node parent &#x3D; searchParent(value);
			&#x2F;&#x2F;如果要删除的结点是叶子结点
			if(targetNode.left &#x3D;&#x3D; null &amp;&amp; targetNode.right &#x3D;&#x3D; null) &#123;
				&#x2F;&#x2F;判断targetNode 是父结点的左子结点，还是右子结点
				if(parent.left !&#x3D; null &amp;&amp; parent.left.value &#x3D;&#x3D; value) &#123; &#x2F;&#x2F;是左子结点
					parent.left &#x3D; null;
				&#125; else if (parent.right !&#x3D; null &amp;&amp; parent.right.value &#x3D;&#x3D; value) &#123;&#x2F;&#x2F;是右子结点
					parent.right &#x3D; null;
				&#125;
			&#125; else if (targetNode.left !&#x3D; null &amp;&amp; targetNode.right !&#x3D; null) &#123; &#x2F;&#x2F;删除有两颗子树的节点
				int minVal &#x3D; delRightTreeMin(targetNode.right);
				targetNode.value &#x3D; minVal;
			
			&#125; else &#123; &#x2F;&#x2F; 删除只有一颗子树的结点
				&#x2F;&#x2F;如果要删除的结点有左子结点 
				if(targetNode.left !&#x3D; null) &#123;
					if(parent !&#x3D; null) &#123;
						&#x2F;&#x2F;如果 targetNode 是 parent 的左子结点
						if(parent.left.value &#x3D;&#x3D; value) &#123;
							parent.left &#x3D; targetNode.left;
						&#125; else &#123; &#x2F;&#x2F;  targetNode 是 parent 的右子结点
							parent.right &#x3D; targetNode.left;
						&#125; 
					&#125; else &#123;
						root &#x3D; targetNode.left;
					&#125;
				&#125; else &#123; &#x2F;&#x2F;如果要删除的结点有右子结点 
					if(parent !&#x3D; null) &#123;
						&#x2F;&#x2F;如果 targetNode 是 parent 的左子结点
						if(parent.left.value &#x3D;&#x3D; value) &#123;
							parent.left &#x3D; targetNode.right;
						&#125; else &#123; &#x2F;&#x2F;如果 targetNode 是 parent 的右子结点
							parent.right &#x3D; targetNode.right;
						&#125;
					&#125; else &#123;
						root &#x3D; targetNode.right;
					&#125;
				&#125;
				
			&#125;
			
		&#125;
	&#125;
	
	&#x2F;&#x2F;添加结点的方法
	public void add(Node node) &#123;
		if(root &#x3D;&#x3D; null) &#123;
			root &#x3D; node;&#x2F;&#x2F;如果root为空则直接让root指向node
		&#125; else &#123;
			root.add(node);
		&#125;
	&#125;
	&#x2F;&#x2F;中序遍历
	public void infixOrder() &#123;
		if(root !&#x3D; null) &#123;
			root.infixOrder();
		&#125; else &#123;
			System.out.println(&quot;二叉排序树为空，不能遍历&quot;);
		&#125;
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-Node" data-language="Node"><code class="language-Node">&#x2F;&#x2F;创建Node结点
class Node &#123;
	int value;
	Node left;
	Node right;
	public Node(int value) &#123;
		
		this.value &#x3D; value;
	&#125;
	
	&#x2F;&#x2F;查找要删除的结点
	&#x2F;**
	 * 
	 * @param value 希望删除的结点的值
	 * @return 如果找到返回该结点，否则返回null
	 *&#x2F;
	public Node search(int value) &#123;
		if(value &#x3D;&#x3D; this.value) &#123; &#x2F;&#x2F;找到就是该结点
			return this;
		&#125; else if(value &lt; this.value) &#123;&#x2F;&#x2F;如果查找的值小于当前结点，向左子树递归查找
			&#x2F;&#x2F;如果左子结点为空
			if(this.left  &#x3D;&#x3D; null) &#123;
				return null;
			&#125;
			return this.left.search(value);
		&#125; else &#123; &#x2F;&#x2F;如果查找的值不小于当前结点，向右子树递归查找
			if(this.right &#x3D;&#x3D; null) &#123;
				return null;
			&#125;
			return this.right.search(value);
		&#125;
		
	&#125;
	&#x2F;&#x2F;查找要删除结点的父结点
	&#x2F;**
	 * 
	 * @param value 要找到的结点的值
	 * @return 返回的是要删除的结点的父结点，如果没有就返回null
	 *&#x2F;
	public Node searchParent(int value) &#123;
		&#x2F;&#x2F;如果当前结点就是要删除的结点的父结点，就返回
		if((this.left !&#x3D; null &amp;&amp; this.left.value &#x3D;&#x3D; value) || 
				(this.right !&#x3D; null &amp;&amp; this.right.value &#x3D;&#x3D; value)) &#123;
			return this;
		&#125; else &#123;
			&#x2F;&#x2F;如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空
			if(value &lt; this.value &amp;&amp; this.left !&#x3D; null) &#123;
				return this.left.searchParent(value); &#x2F;&#x2F;向左子树递归查找
			&#125; else if (value &gt;&#x3D; this.value &amp;&amp; this.right !&#x3D; null) &#123;
				return this.right.searchParent(value); &#x2F;&#x2F;向右子树递归查找
			&#125; else &#123;
				return null; &#x2F;&#x2F; 没有找到父结点
			&#125;
		&#125;
		
	&#125;
	
	@Override
	public String toString() &#123;
		return &quot;Node [value&#x3D;&quot; + value + &quot;]&quot;;
	&#125;

	&#x2F;&#x2F;添加结点的方法
	&#x2F;&#x2F;递归的形式添加结点，注意需要满足二叉排序树的要求
	public void add(Node node) &#123;
		if(node &#x3D;&#x3D; null) &#123;
			return;
		&#125;
		
		&#x2F;&#x2F;判断传入的结点的值，和当前子树的根结点的值关系
		if(node.value &lt; this.value) &#123;
			&#x2F;&#x2F;如果当前结点左子结点为null
			if(this.left &#x3D;&#x3D; null) &#123;
				this.left &#x3D; node;
			&#125; else &#123;
				&#x2F;&#x2F;递归的向左子树添加
				this.left.add(node);
			&#125;
		&#125; else &#123; &#x2F;&#x2F;添加的结点的值大于 当前结点的值
			if(this.right &#x3D;&#x3D; null) &#123;
				this.right &#x3D; node;
			&#125; else &#123;
				&#x2F;&#x2F;递归的向右子树添加
				this.right.add(node);
			&#125;
		&#125;
	&#125;
	
	&#x2F;&#x2F;中序遍历
	public void infixOrder() &#123;
		if(this.left !&#x3D; null) &#123;
			this.left.infixOrder();
		&#125;
		System.out.println(this);
		if(this.right !&#x3D; null) &#123;
			this.right.infixOrder();
		&#125;
	&#125;
	
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="11-3-平衡二叉树"><a href="#11-3-平衡二叉树" class="headerlink" title="11.3 平衡二叉树"></a>11.3 平衡二叉树</h4><h5 id="11-3-1-概述-1"><a href="#11-3-1-概述-1" class="headerlink" title="11.3.1 概述"></a>11.3.1 概述</h5><p>​    平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。<br>​    具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</p>
<h5 id="11-3-2-单旋转-左旋转"><a href="#11-3-2-单旋转-左旋转" class="headerlink" title="11.3.2 单旋转(左旋转)"></a>11.3.2 单旋转(左旋转)</h5><p>要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8}</p>
<p>思路分析(示意图)</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646382417793.png" alt="1646382417793"></p>
<p>代码实现 ：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private void leftRotate() &#123;
	Node newLeft &#x3D; new Node(value);
	newLeft.left&#x3D;left;
	newLeft.right&#x3D;right.left;
	value&#x3D;right.value;
	right&#x3D;right.right;
	left&#x3D;newLeft;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="11-3-3-单旋转-右旋转"><a href="#11-3-3-单旋转-右旋转" class="headerlink" title="11.3.3 单旋转(右旋转)"></a>11.3.3 单旋转(右旋转)</h5><p>要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}</p>
<p>思路分析(示意图)</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646382599113.png" alt="1646382599113"></p>
<p>代码实现 ：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private void rightRotate() &#123;
	Node newNode &#x3D; new Node(value);
	newNode.right &#x3D; right;
	newNode.left &#x3D; left.right;
	value &#x3D; left.value;
	left &#x3D; left.left;
	right &#x3D; newNode;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="11-3-4-双旋转"><a href="#11-3-4-双旋转" class="headerlink" title="11.3.4 双旋转"></a>11.3.4 双旋转</h5><p>前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列<br>int[] arr &#x3D; { 10, 11, 7, 6, 8, 9 };  运行原来的代码可以看到，并没有转成 AVL树.<br>int[] arr &#x3D; {2,1,6,5,7,3}; &#x2F;&#x2F; 运行原来的代码可以看到，并没有转成 AVL树</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转
if(rightHeight() - leftHeight() &gt; 1) &#123;
	&#x2F;&#x2F;如果它的右子树的左子树的高度大于它的右子树的右子树的高度
	if(right !&#x3D; null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;
		&#x2F;&#x2F;先对右子结点进行右旋转
		right.rightRotate();
		&#x2F;&#x2F;然后在对当前结点进行左旋转
		leftRotate(); &#x2F;&#x2F;左旋转..
	&#125; else &#123;
		&#x2F;&#x2F;直接进行左旋转即可
		leftRotate();
	&#125;
	return ; &#x2F;&#x2F;必须要!!!
&#125;

&#x2F;&#x2F;当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转
if(leftHeight() - rightHeight() &gt; 1) &#123;
	&#x2F;&#x2F;如果它的左子树的右子树高度大于它的左子树的高度
	if(left !&#x3D; null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;
		&#x2F;&#x2F;先对当前结点的左结点(左子树)-&gt;左旋转
		left.leftRotate();
		&#x2F;&#x2F;再对当前结点进行右旋转
		rightRotate();
	&#125; else &#123;
		&#x2F;&#x2F;直接进行右旋转即可
		rightRotate();
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="11-3-5-总体实现"><a href="#11-3-5-总体实现" class="headerlink" title="11.3.5 总体实现"></a>11.3.5 总体实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class AVLTreeDemo &#123;
	public static void main(String[] args) &#123;
		&#x2F;&#x2F;int[] arr &#x3D; &#123;4,3,6,5,7,8&#125;;
		&#x2F;&#x2F;int[] arr &#x3D; &#123; 10, 12, 8, 9, 7, 6 &#125;;
		int[] arr &#x3D; &#123; 10, 11, 7, 6, 8, 9 &#125;;  
		&#x2F;&#x2F;创建一个 AVLTree对象
		AVLTree avlTree &#x3D; new AVLTree();
		&#x2F;&#x2F;添加结点
		for(int i&#x3D;0; i &lt; arr.length; i++) &#123;
			avlTree.add(new Node(arr[i]));
		&#125;
		
		&#x2F;&#x2F;遍历
		System.out.println(&quot;中序遍历&quot;);
		avlTree.infixOrder();
		
		System.out.println(&quot;在平衡处理~~&quot;);
		System.out.println(&quot;树的高度&#x3D;&quot; + avlTree.getRoot().height()); &#x2F;&#x2F;3
		System.out.println(&quot;树的左子树高度&#x3D;&quot; + avlTree.getRoot().leftHeight()); &#x2F;&#x2F; 2
		System.out.println(&quot;树的右子树高度&#x3D;&quot; + avlTree.getRoot().rightHeight()); &#x2F;&#x2F; 2
		System.out.println(&quot;当前的根结点&#x3D;&quot; + avlTree.getRoot());&#x2F;&#x2F;8
	&#125;

&#125;

&#x2F;&#x2F; 创建AVLTree
class AVLTree &#123;
	private Node root;

	public Node getRoot() &#123;
		return root;
	&#125;

	&#x2F;&#x2F; 查找要删除的结点
	public Node search(int value) &#123;
		if (root &#x3D;&#x3D; null) &#123;
			return null;
		&#125; else &#123;
			return root.search(value);
		&#125;
	&#125;

	&#x2F;&#x2F; 查找父结点
	public Node searchParent(int value) &#123;
		if (root &#x3D;&#x3D; null) &#123;
			return null;
		&#125; else &#123;
			return root.searchParent(value);
		&#125;
	&#125;

	&#x2F;&#x2F; 编写方法:
	&#x2F;&#x2F; 1. 返回的 以node 为根结点的二叉排序树的最小结点的值
	&#x2F;&#x2F; 2. 删除node 为根结点的二叉排序树的最小结点
	&#x2F;**
	 * 
	 * @param node
	 *            传入的结点(当做二叉排序树的根结点)
	 * @return 返回的 以node 为根结点的二叉排序树的最小结点的值
	 *&#x2F;
	public int delRightTreeMin(Node node) &#123;
		Node target &#x3D; node;
		&#x2F;&#x2F; 循环的查找左子节点，就会找到最小值
		while (target.left !&#x3D; null) &#123;
			target &#x3D; target.left;
		&#125;
		&#x2F;&#x2F; 这时 target就指向了最小结点
		&#x2F;&#x2F; 删除最小结点
		delNode(target.value);
		return target.value;
	&#125;

	&#x2F;&#x2F; 删除结点
	public void delNode(int value) &#123;
		if (root &#x3D;&#x3D; null) &#123;
			return;
		&#125; else &#123;
			&#x2F;&#x2F; 1.需求先去找到要删除的结点 targetNode
			Node targetNode &#x3D; search(value);
			&#x2F;&#x2F; 如果没有找到要删除的结点
			if (targetNode &#x3D;&#x3D; null) &#123;
				return;
			&#125;
			&#x2F;&#x2F; 如果我们发现当前这颗二叉排序树只有一个结点
			if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;
				root &#x3D; null;
				return;
			&#125;

			&#x2F;&#x2F; 去找到targetNode的父结点
			Node parent &#x3D; searchParent(value);
			&#x2F;&#x2F; 如果要删除的结点是叶子结点
			if (targetNode.left &#x3D;&#x3D; null &amp;&amp; targetNode.right &#x3D;&#x3D; null) &#123;
				&#x2F;&#x2F; 判断targetNode 是父结点的左子结点，还是右子结点
				if (parent.left !&#x3D; null &amp;&amp; parent.left.value &#x3D;&#x3D; value) &#123; &#x2F;&#x2F; 是左子结点
					parent.left &#x3D; null;
				&#125; else if (parent.right !&#x3D; null &amp;&amp; parent.right.value &#x3D;&#x3D; value) &#123;&#x2F;&#x2F; 是由子结点
					parent.right &#x3D; null;
				&#125;
			&#125; else if (targetNode.left !&#x3D; null &amp;&amp; targetNode.right !&#x3D; null) &#123; &#x2F;&#x2F; 删除有两颗子树的节点
				int minVal &#x3D; delRightTreeMin(targetNode.right);
				targetNode.value &#x3D; minVal;

			&#125; else &#123; &#x2F;&#x2F; 删除只有一颗子树的结点
				&#x2F;&#x2F; 如果要删除的结点有左子结点
				if (targetNode.left !&#x3D; null) &#123;
					if (parent !&#x3D; null) &#123;
						&#x2F;&#x2F; 如果 targetNode 是 parent 的左子结点
						if (parent.left.value &#x3D;&#x3D; value) &#123;
							parent.left &#x3D; targetNode.left;
						&#125; else &#123; &#x2F;&#x2F; targetNode 是 parent 的右子结点
							parent.right &#x3D; targetNode.left;
						&#125;
					&#125; else &#123;
						root &#x3D; targetNode.left;
					&#125;
				&#125; else &#123; &#x2F;&#x2F; 如果要删除的结点有右子结点
					if (parent !&#x3D; null) &#123;
						&#x2F;&#x2F; 如果 targetNode 是 parent 的左子结点
						if (parent.left.value &#x3D;&#x3D; value) &#123;
							parent.left &#x3D; targetNode.right;
						&#125; else &#123; &#x2F;&#x2F; 如果 targetNode 是 parent 的右子结点
							parent.right &#x3D; targetNode.right;
						&#125;
					&#125; else &#123;
						root &#x3D; targetNode.right;
					&#125;
				&#125;

			&#125;

		&#125;
	&#125;

	&#x2F;&#x2F; 添加结点的方法
	public void add(Node node) &#123;
		if (root &#x3D;&#x3D; null) &#123;
			root &#x3D; node;&#x2F;&#x2F; 如果root为空则直接让root指向node
		&#125; else &#123;
			root.add(node);
		&#125;
	&#125;

	&#x2F;&#x2F; 中序遍历
	public void infixOrder() &#123;
		if (root !&#x3D; null) &#123;
			root.infixOrder();
		&#125; else &#123;
			System.out.println(&quot;二叉排序树为空，不能遍历&quot;);
		&#125;
	&#125;
&#125;

&#x2F;&#x2F; 创建Node结点
class Node &#123;
	int value;
	Node left;
	Node right;

	public Node(int value) &#123;

		this.value &#x3D; value;
	&#125;

	&#x2F;&#x2F; 返回左子树的高度
	public int leftHeight() &#123;
		if (left &#x3D;&#x3D; null) &#123;
			return 0;
		&#125;
		return left.height();
	&#125;

	&#x2F;&#x2F; 返回右子树的高度
	public int rightHeight() &#123;
		if (right &#x3D;&#x3D; null) &#123;
			return 0;
		&#125;
		return right.height();
	&#125;

	&#x2F;&#x2F; 返回 以该结点为根结点的树的高度
	public int height() &#123;
		return Math.max(left &#x3D;&#x3D; null ? 0 : left.height(), right &#x3D;&#x3D; null ? 0 : right.height()) + 1;
	&#125;
	
	&#x2F;&#x2F;左旋转方法
	private void leftRotate() &#123;
		
		&#x2F;&#x2F;创建新的结点，以当前根结点的值
		Node newNode &#x3D; new Node(value);
		&#x2F;&#x2F;把新的结点的左子树设置成当前结点的左子树
		newNode.left &#x3D; left;
		&#x2F;&#x2F;把新的结点的右子树设置成带你过去结点的右子树的左子树
		newNode.right &#x3D; right.left;
		&#x2F;&#x2F;把当前结点的值替换成右子结点的值
		value &#x3D; right.value;
		&#x2F;&#x2F;把当前结点的右子树设置成当前结点右子树的右子树
		right &#x3D; right.right;
		&#x2F;&#x2F;把当前结点的左子树(左子结点)设置成新的结点
		left &#x3D; newNode;
		
		
	&#125;
	
	&#x2F;&#x2F;右旋转
	private void rightRotate() &#123;
		Node newNode &#x3D; new Node(value);
		newNode.right &#x3D; right;
		newNode.left &#x3D; left.right;
		value &#x3D; left.value;
		left &#x3D; left.left;
		right &#x3D; newNode;
	&#125;

	&#x2F;&#x2F; 查找要删除的结点
	&#x2F;**
	 * 
	 * @param value
	 *            希望删除的结点的值
	 * @return 如果找到返回该结点，否则返回null
	 *&#x2F;
	public Node search(int value) &#123;
		if (value &#x3D;&#x3D; this.value) &#123; &#x2F;&#x2F; 找到就是该结点
			return this;
		&#125; else if (value &lt; this.value) &#123;&#x2F;&#x2F; 如果查找的值小于当前结点，向左子树递归查找
			&#x2F;&#x2F; 如果左子结点为空
			if (this.left &#x3D;&#x3D; null) &#123;
				return null;
			&#125;
			return this.left.search(value);
		&#125; else &#123; &#x2F;&#x2F; 如果查找的值不小于当前结点，向右子树递归查找
			if (this.right &#x3D;&#x3D; null) &#123;
				return null;
			&#125;
			return this.right.search(value);
		&#125;

	&#125;

	&#x2F;&#x2F; 查找要删除结点的父结点
	&#x2F;**
	 * 
	 * @param value 要找到的结点的值
	 *           
	 * @return 返回的是要删除的结点的父结点，如果没有就返回null
	 *&#x2F;
	public Node searchParent(int value) &#123;
		&#x2F;&#x2F; 如果当前结点就是要删除的结点的父结点，就返回
		if ((this.left !&#x3D; null &amp;&amp; this.left.value &#x3D;&#x3D; value) || (this.right !&#x3D; null &amp;&amp; this.right.value &#x3D;&#x3D; value)) &#123;
			return this;
		&#125; else &#123;
			&#x2F;&#x2F; 如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空
			if (value &lt; this.value &amp;&amp; this.left !&#x3D; null) &#123;
				return this.left.searchParent(value); &#x2F;&#x2F; 向左子树递归查找
			&#125; else if (value &gt;&#x3D; this.value &amp;&amp; this.right !&#x3D; null) &#123;
				return this.right.searchParent(value); &#x2F;&#x2F; 向右子树递归查找
			&#125; else &#123;
				return null; &#x2F;&#x2F; 没有找到父结点
			&#125;
		&#125;

	&#125;

	@Override
	public String toString() &#123;
		return &quot;Node [value&#x3D;&quot; + value + &quot;]&quot;;
	&#125;

	&#x2F;&#x2F; 添加结点的方法
	&#x2F;&#x2F; 递归的形式添加结点，注意需要满足二叉排序树的要求
	public void add(Node node) &#123;
		if (node &#x3D;&#x3D; null) &#123;
			return;
		&#125;

		&#x2F;&#x2F; 判断传入的结点的值，和当前子树的根结点的值关系
		if (node.value &lt; this.value) &#123;
			&#x2F;&#x2F; 如果当前结点左子结点为null
			if (this.left &#x3D;&#x3D; null) &#123;
				this.left &#x3D; node;
			&#125; else &#123;
				&#x2F;&#x2F; 递归的向左子树添加
				this.left.add(node);
			&#125;
		&#125; else &#123; &#x2F;&#x2F; 添加的结点的值大于 当前结点的值
			if (this.right &#x3D;&#x3D; null) &#123;
				this.right &#x3D; node;
			&#125; else &#123;
				&#x2F;&#x2F; 递归的向右子树添加
				this.right.add(node);
			&#125;

		&#125;
		
		&#x2F;&#x2F;当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转
		if(rightHeight() - leftHeight() &gt; 1) &#123;
			&#x2F;&#x2F;如果它的右子树的左子树的高度大于它的右子树的右子树的高度
			if(right !&#x3D; null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;
				&#x2F;&#x2F;先对右子结点进行右旋转
				right.rightRotate();
				&#x2F;&#x2F;然后在对当前结点进行左旋转
				leftRotate(); &#x2F;&#x2F;左旋转..
			&#125; else &#123;
				&#x2F;&#x2F;直接进行左旋转即可
				leftRotate();
			&#125;
			return ; &#x2F;&#x2F;必须要!!!
		&#125;
		
		&#x2F;&#x2F;当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转
		if(leftHeight() - rightHeight() &gt; 1) &#123;
			&#x2F;&#x2F;如果它的左子树的右子树高度大于它的左子树的高度
			if(left !&#x3D; null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;
				&#x2F;&#x2F;先对当前结点的左结点(左子树)-&gt;左旋转
				left.leftRotate();
				&#x2F;&#x2F;再对当前结点进行右旋转
				rightRotate();
			&#125; else &#123;
				&#x2F;&#x2F;直接进行右旋转即可
				rightRotate();
			&#125;
		&#125;
	&#125;

	&#x2F;&#x2F; 中序遍历
	public void infixOrder() &#123;
		if (this.left !&#x3D; null) &#123;
			this.left.infixOrder();
		&#125;
		System.out.println(this);
		if (this.right !&#x3D; null) &#123;
			this.right.infixOrder();
		&#125;
	&#125;

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="12-多路查找树"><a href="#12-多路查找树" class="headerlink" title="12 多路查找树"></a>12 多路查找树</h3><h4 id="12-1-B树"><a href="#12-1-B树" class="headerlink" title="12.1 B树"></a>12.1 B树</h4><h5 id="12-1-1-概述"><a href="#12-1-1-概述" class="headerlink" title="12.1.1 概述"></a>12.1.1 概述</h5><p>B-tree 树即 B 树，B 即 Balanced，平衡的意思。有人把 B-tree 翻译成 B-树，容易让人产生误解。会以为 B-树是一种树，而 B 树又是另一种树。实际上，B-tree 就是指的 B 树。</p>
<p>2-3 树和 2-3-4 树，他们就是 B 树(英语：B-tree 也写成 B-树)，这里我们再做一个说明，我们在学习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图:</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps7056.tmp.jpg" alt="img"> </p>
<ol>
<li><p>B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4</p>
</li>
<li><p>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</p>
</li>
<li><p>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据</p>
</li>
<li><p>搜索有可能在非叶子结点结束</p>
</li>
<li><p>其搜索性能等价于在关键字全集内做一次二分查找</p>
</li>
</ol>
<p>B 树通过重新组织节点，降低树的高度，并且减少 i&#x2F;o 读写次数来提升效率</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps2138.tmp.jpg" alt="img"> </p>
<ol>
<li><p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)</p>
</li>
<li><p>将树的度 M 设置为 1024，在 600 亿个元素中最多只需要 4 次 I&#x2F;O 操作就可以读取到想要的元素, B 树(B+)广泛应用于文件存储系统以及数据库系统中这样每个节点只需要一次 I&#x2F;O 就可以完全载入</p>
</li>
</ol>
<h5 id="12-1-2-2-3树"><a href="#12-1-2-2-3树" class="headerlink" title="12.1.2 2-3树"></a>12.1.2 2-3树</h5><p>2-3树是最简单的 B 树结构, 具有如下特点：</p>
<ol>
<li><p>2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)</p>
</li>
<li><p>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</p>
</li>
<li><p>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.</p>
</li>
<li><p>2-3 树是由二节点和三节点构成的树</p>
</li>
</ol>
<h5 id="12-1-3-2-3树的应用场景"><a href="#12-1-3-2-3树的应用场景" class="headerlink" title="12.1.3 2-3树的应用场景"></a>12.1.3 2-3树的应用场景</h5><p>将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps5FEE.tmp.jpg" alt="img"> </p>
<p>规则：</p>
<ol>
<li><p>2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)</p>
</li>
<li><p>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</p>
</li>
<li><p>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</p>
</li>
<li><p>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则</p>
</li>
</ol>
<p>除了 2-3 树，还有 2-3-4 树等，概念和 2-3 树类似，也是一种 B 树</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps5FFF.tmp.jpg" alt="img"> </p>
<h4 id="12-2-B-树"><a href="#12-2-B-树" class="headerlink" title="12.2 B+树"></a>12.2 B+树</h4><p>B+树是 B 树的变体，也是一种多路搜索树。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsBCAD.tmp.jpg" alt="img"> </p>
<p>对上图的说明：</p>
<ol>
<li><p>B+树的搜索与 B 树也基本相同，区别是 B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</p>
</li>
<li><p>所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。</p>
</li>
<li><p>不可能在非叶子结点命中</p>
</li>
<li><p>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</p>
</li>
<li><p>更适合文件索引系统</p>
</li>
<li><p>B 树和 B+树各有自己的应用场景，不能说 B+树完全比 B 树好，反之亦然.</p>
</li>
</ol>
<h4 id="12-3-B-树"><a href="#12-3-B-树" class="headerlink" title="12.3 B*树"></a>12.3 B*树</h4><p>B*树是 B+树的变体，在 B+树的 非根和非叶子结点再增指向兄弟的指针</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps9640.tmp.jpg" alt="img"> </p>
<p>B*树的说明：</p>
<ol>
<li><p>B树定义了非叶子结点关键字个数至少为(2&#x2F;3)M，即块的最低使用率为 2&#x2F;3，而 B+树的块的最低使用率为的1&#x2F;2。</p>
</li>
<li><p>从第 1 个特点我们可以看出，B*树分配新结点的概率比 B+树要低，空间使用率更高</p>
</li>
</ol>
<h3 id="13-图"><a href="#13-图" class="headerlink" title="13 图"></a>13 图</h3><h4 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h4><p>在数学中，图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并且每个相关的顶点对都称为边（也称为链接或线）。通常，图形以图解形式描绘为顶点的一组点或环，并通过边的线或曲线连接。 </p>
<p>当需要表示多对多的关系时，用图表示。</p>
<h4 id="13-2-常用术语"><a href="#13-2-常用术语" class="headerlink" title="13.2 常用术语"></a>13.2 常用术语</h4><p>顶点(vertex)</p>
<p>边(edge)</p>
<p>路径</p>
<p>无向图：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646387441347.png" alt="1646387441347"></p>
<p>有向图，带权图：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646387480507.png" alt="1646387480507"></p>
<h4 id="13-3-表达方式"><a href="#13-3-表达方式" class="headerlink" title="13.3 表达方式"></a>13.3 表达方式</h4><p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接列表）。</p>
<h5 id="13-3-1-邻接矩阵"><a href="#13-3-1-邻接矩阵" class="headerlink" title="13.3.1 邻接矩阵"></a>13.3.1 邻接矩阵</h5><p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1….n个点。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646387643890.png" alt="1646387643890"></p>
<h5 id="13-3-2-邻接表"><a href="#13-3-2-邻接表" class="headerlink" title="13.3.2 邻接表"></a>13.3.2 邻接表</h5><ol>
<li><p>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失。</p>
</li>
<li><p>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成。</p>
</li>
</ol>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646387766087.png" alt="1646387766087"></p>
<h4 id="13-4-基本实现"><a href="#13-4-基本实现" class="headerlink" title="13.4 基本实现"></a>13.4 基本实现</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646401145738.png" alt="1646401145738"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;

public class Graph &#123;

	private ArrayList&lt;String&gt; vertexList; &#x2F;&#x2F;存储顶点集合
	private int[][] edges; &#x2F;&#x2F;存储图对应的邻结矩阵
	private int numOfEdges; &#x2F;&#x2F;表示边的数目
	
	public static void main(String[] args) &#123;
		&#x2F;&#x2F;测试一把图是否创建ok
		int n &#x3D; 8;  &#x2F;&#x2F;结点的个数
		String Vertexs[] &#x3D; &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;;
		
		&#x2F;&#x2F;创建图对象
		Graph graph &#x3D; new Graph(n);
		&#x2F;&#x2F;循环的添加顶点
		for(String vertex: Vertexs) &#123;
			graph.insertVertex(vertex);
		&#125;
		
		&#x2F;&#x2F;添加边
		&#x2F;&#x2F;A-B A-C B-C B-D B-E 
		graph.insertEdge(0, 1, 1); &#x2F;&#x2F; A-B
		graph.insertEdge(0, 2, 1); &#x2F;&#x2F; 
		graph.insertEdge(1, 2, 1); &#x2F;&#x2F; 
		graph.insertEdge(1, 3, 1); &#x2F;&#x2F; 
		graph.insertEdge(1, 4, 1); &#x2F;&#x2F; 

		&#x2F;&#x2F;显示一把邻结矩阵
		graph.showGraph();		
	&#125;
	
	&#x2F;&#x2F;构造器
	public Graph(int n) &#123;
		&#x2F;&#x2F;初始化矩阵和vertexList
		edges &#x3D; new int[n][n];
		vertexList &#x3D; new ArrayList&lt;String&gt;(n);
		numOfEdges &#x3D; 0;
		
	&#125;
	
	&#x2F;&#x2F;图中常用的方法
	&#x2F;&#x2F;返回结点的个数
	public int getNumOfVertex() &#123;
		return vertexList.size();
	&#125;
	&#x2F;&#x2F;显示图对应的矩阵
	public void showGraph() &#123;
		for(int[] link : edges) &#123;
			System.err.println(Arrays.toString(link));
		&#125;
	&#125;
	&#x2F;&#x2F;得到边的数目
	public int getNumOfEdges() &#123;
		return numOfEdges;
	&#125;
	&#x2F;&#x2F;返回结点i(下标)对应的数据 0-&gt;&quot;A&quot; 1-&gt;&quot;B&quot; 2-&gt;&quot;C&quot;
	public String getValueByIndex(int i) &#123;
		return vertexList.get(i);
	&#125;
	&#x2F;&#x2F;返回v1和v2的权值
	public int getWeight(int v1, int v2) &#123;
		return edges[v1][v2];
	&#125;
	&#x2F;&#x2F;插入结点
	public void insertVertex(String vertex) &#123;
		vertexList.add(vertex);
	&#125;
	&#x2F;&#x2F;添加边
	&#x2F;**
	 * 
	 * @param v1 表示点的下标即使第几个顶点  &quot;A&quot;-&quot;B&quot; &quot;A&quot;-&gt;0 &quot;B&quot;-&gt;1
	 * @param v2 第二个顶点对应的下标
	 * @param weight 表示 
	 *&#x2F;
	public void insertEdge(int v1, int v2, int weight) &#123;
		edges[v1][v2] &#x3D; weight;
		edges[v2][v1] &#x3D; weight;
		numOfEdges++;
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="13-5-图的深度优先遍历"><a href="#13-5-图的深度优先遍历" class="headerlink" title="13.5 图的深度优先遍历"></a>13.5 图的深度优先遍历</h4><h5 id="13-5-1-概述"><a href="#13-5-1-概述" class="headerlink" title="13.5.1 概述"></a>13.5.1 概述</h5><p>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search.其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p>
<h5 id="13-5-2-原理"><a href="#13-5-2-原理" class="headerlink" title="13.5.2 原理"></a>13.5.2 原理</h5><p>深度优先遍历（Depth-First-Search），从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问，第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</p>
<p>深度优先搜索是一个递归的过程</p>
<h5 id="13-5-3-算法步骤"><a href="#13-5-3-算法步骤" class="headerlink" title="13.5.3 算法步骤"></a>13.5.3 算法步骤</h5><ol>
<li><p>访问初始结点v，并标记结点v为已访问。</p>
</li>
<li><p>查找结点v的第一个邻接结点w。</p>
</li>
<li><p>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</p>
</li>
<li><p>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</p>
</li>
<li><p>查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</p>
</li>
</ol>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646402800758.png" alt="1646402800758"></p>
<h5 id="13-5-4-实现"><a href="#13-5-4-实现" class="headerlink" title="13.5.4 实现"></a>13.5.4 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.Arrays;

public class Graph &#123;

    private ArrayList&lt;String&gt; vertexList; &#x2F;&#x2F;存储顶点集合
    private int[][] edges; &#x2F;&#x2F;存储图对应的邻结矩阵
    private int numOfEdges; &#x2F;&#x2F;表示边的数目
    private boolean[] isVisited; &#x2F;&#x2F;定义给数组boolean[], 记录某个结点是否被访问

    public static void main(String[] args) &#123;
        &#x2F;&#x2F;测试一把图是否创建ok
        int n &#x3D; 8;  &#x2F;&#x2F;结点的个数
        String Vertexs[] &#x3D; &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;;

        &#x2F;&#x2F;创建图对象
        Graph graph &#x3D; new Graph(n);
        &#x2F;&#x2F;循环的添加顶点
        for(String vertex: Vertexs) &#123;
            graph.insertVertex(vertex);
        &#125;

        &#x2F;&#x2F;添加边
        &#x2F;&#x2F;A-B A-C B-C B-D B-E
        graph.insertEdge(0, 1, 1); &#x2F;&#x2F; A-B
        graph.insertEdge(0, 2, 1); &#x2F;&#x2F;
        graph.insertEdge(1, 2, 1); &#x2F;&#x2F;
        graph.insertEdge(1, 3, 1); &#x2F;&#x2F;
        graph.insertEdge(1, 4, 1); &#x2F;&#x2F;

        &#x2F;&#x2F;显示一把邻结矩阵
        graph.showGraph();

        graph.dfs();
    &#125;

    &#x2F;&#x2F;构造器
    public Graph(int n) &#123;
        &#x2F;&#x2F;初始化矩阵和vertexList
        edges &#x3D; new int[n][n];
        vertexList &#x3D; new ArrayList&lt;String&gt;(n);
        numOfEdges &#x3D; 0;

    &#125;

    &#x2F;&#x2F;图中常用的方法
    &#x2F;&#x2F;返回结点的个数
    public int getNumOfVertex() &#123;
        return vertexList.size();
    &#125;
    &#x2F;&#x2F;显示图对应的矩阵
    public void showGraph() &#123;
        for(int[] link : edges) &#123;
            System.err.println(Arrays.toString(link));
        &#125;
    &#125;
    &#x2F;&#x2F;得到边的数目
    public int getNumOfEdges() &#123;
        return numOfEdges;
    &#125;
    &#x2F;&#x2F;返回结点i(下标)对应的数据 0-&gt;&quot;A&quot; 1-&gt;&quot;B&quot; 2-&gt;&quot;C&quot;
    public String getValueByIndex(int i) &#123;
        return vertexList.get(i);
    &#125;
    &#x2F;&#x2F;返回v1和v2的权值
    public int getWeight(int v1, int v2) &#123;
        return edges[v1][v2];
    &#125;
    &#x2F;&#x2F;插入结点
    public void insertVertex(String vertex) &#123;
        vertexList.add(vertex);
    &#125;
    &#x2F;&#x2F;添加边
    &#x2F;**
     *
     * @param v1 表示点的下标即使第几个顶点  &quot;A&quot;-&quot;B&quot; &quot;A&quot;-&gt;0 &quot;B&quot;-&gt;1
     * @param v2 第二个顶点对应的下标
     * @param weight 表示
     *&#x2F;
    public void insertEdge(int v1, int v2, int weight) &#123;
        edges[v1][v2] &#x3D; weight;
        edges[v2][v1] &#x3D; weight;
        numOfEdges++;
    &#125;
    &#x2F;&#x2F;得到第一个邻接结点的下标 w
    &#x2F;**
     *
     * @param index
     * @return 如果存在就返回对应的下标，否则返回-1
     *&#x2F;
    public int getFirstNeighbor(int index)&#123;
        for (int i &#x3D; 0;i &lt; getNumOfVertex();i++)&#123;
            if (edges[index][i] &gt; 0)&#123;
                return i;
            &#125;
        &#125;
        return -1;
    &#125;
    &#x2F;&#x2F;根据前一个邻接结点的下标来获取下一个邻接结点  v1,v2是前一个邻接节点的下标
    public int getNextNeighbor(int v1, int v2) &#123;
        for (int j &#x3D; v2 + 1;j &lt; getNumOfVertex();j++)&#123;
            if (edges[v1][j] &gt; 0)&#123;
                return j;
            &#125;
        &#125;
        return -1;
    &#125;

    &#x2F;&#x2F;深度优先遍历算法
    &#x2F;&#x2F;i 第一次就是 0
    private void dfs(boolean[] isVisited, int i)&#123;
        System.out.print(getValueByIndex(i) + &quot;-&gt;&quot;);
        isVisited[i] &#x3D; true;
        int w &#x3D; getFirstNeighbor(i);
        while (w!&#x3D;-1)&#123;
            if (!isVisited[w])&#123;
                dfs(isVisited,w);
            &#125;
            w &#x3D; getNextNeighbor(i,w);
        &#125;
    &#125;

    public void dfs()&#123;
        isVisited &#x3D; new boolean[vertexList.size()];
        &#x2F;&#x2F;遍历所有的结点，进行dfs[回溯]
        for(int i &#x3D; 0; i &lt; getNumOfVertex(); i++) &#123;
            if(!isVisited[i]) &#123;
                dfs(isVisited, i);
            &#125;
        &#125;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="13-6-图的广度优先遍历"><a href="#13-6-图的广度优先遍历" class="headerlink" title="13.6 图的广度优先遍历"></a>13.6 图的广度优先遍历</h4><h5 id="13-6-1-概述"><a href="#13-6-1-概述" class="headerlink" title="13.6.1 概述"></a>13.6.1 概述</h5><p>宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。 </p>
<p>BFS，其英文全称是Breadth First Search。 BFS并不使用经验法则算法。从算法的观点，所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中。一般的实验里，其邻居节点尚未被检验过的节点会被放置在一个被称为 open 的容器中（例如队列或是链表），而被检验过的节点则被放置在被称为 closed 的容器中。 </p>
<h5 id="13-6-2-原理"><a href="#13-6-2-原理" class="headerlink" title="13.6.2 原理"></a>13.6.2 原理</h5><p>类似于一个 分层搜索的过程，广度优先遍历（Breadth-First-Search）需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</p>
<h5 id="13-6-3-算法步骤"><a href="#13-6-3-算法步骤" class="headerlink" title="13.6.3 算法步骤"></a>13.6.3 算法步骤</h5><ol>
<li><p>访问初始结点 v 并标记结点 v 为已访问。</p>
</li>
<li><p>结点 v 入队列</p>
</li>
<li><p>当队列非空时，继续执行，否则算法结束。</p>
</li>
<li><p>出队列，取得队头结点 u。</p>
</li>
<li><p>查找结点 u 的第一个邻接结点 w。</p>
</li>
<li><p>若结点 u 的邻接结点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤<br>6.1 若结点 w 尚未被访问，则访问结点 w 并标记为已访问。</p>
<p>6.2 结点 w 入队列。</p>
<p>6.3 查找结点 u 的继 w 接结点后的下一个邻接结点 w，转到步骤 6</p>
</li>
</ol>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps9673.tmp.jpg" alt="img"></p>
<h5 id="13-6-4-实现"><a href="#13-6-4-实现" class="headerlink" title="13.6.4 实现"></a>13.6.4 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;

public class Graph &#123;

    private ArrayList&lt;String&gt; vertexList; &#x2F;&#x2F;存储顶点集合
    private int[][] edges; &#x2F;&#x2F;存储图对应的邻结矩阵
    private int numOfEdges; &#x2F;&#x2F;表示边的数目
    private boolean[] isVisited; &#x2F;&#x2F;定义给数组boolean[], 记录某个结点是否被访问

    public static void main(String[] args) &#123;
        &#x2F;&#x2F;测试一把图是否创建ok
		int n &#x3D; 8;  &#x2F;&#x2F;结点的个数
		&#x2F;&#x2F;String Vertexs[] &#x3D; &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;;
		String Vertexs[] &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;&#125;;
		
		&#x2F;&#x2F;创建图对象
		Graph graph &#x3D; new Graph(n);
		&#x2F;&#x2F;循环的添加顶点
		for(String vertex: Vertexs) &#123;
			graph.insertVertex(vertex);
		&#125;
		
		&#x2F;&#x2F;添加边
		&#x2F;&#x2F;A-B A-C B-C B-D B-E 
&#x2F;&#x2F;		graph.insertEdge(0, 1, 1); &#x2F;&#x2F; A-B
&#x2F;&#x2F;		graph.insertEdge(0, 2, 1); &#x2F;&#x2F; 
&#x2F;&#x2F;		graph.insertEdge(1, 2, 1); &#x2F;&#x2F; 
&#x2F;&#x2F;		graph.insertEdge(1, 3, 1); &#x2F;&#x2F; 
&#x2F;&#x2F;		graph.insertEdge(1, 4, 1); &#x2F;&#x2F; 
		
		&#x2F;&#x2F;更新边的关系
		graph.insertEdge(0, 1, 1);
		graph.insertEdge(0, 2, 1);
		graph.insertEdge(1, 3, 1);
		graph.insertEdge(1, 4, 1);
		graph.insertEdge(3, 7, 1);
		graph.insertEdge(4, 7, 1);
		graph.insertEdge(2, 5, 1);
		graph.insertEdge(2, 6, 1);
		graph.insertEdge(5, 6, 1);

		
		
		&#x2F;&#x2F;显示一把邻结矩阵
		graph.showGraph();
		
		&#x2F;&#x2F;测试一把，我们的dfs遍历是否ok
		System.out.println(&quot;深度遍历&quot;);
		graph.dfs(); &#x2F;&#x2F; A-&gt;B-&gt;C-&gt;D-&gt;E [1-&gt;2-&gt;4-&gt;8-&gt;5-&gt;3-&gt;6-&gt;7]
		System.out.println();
		System.out.println(&quot;广度优先!&quot;);
		graph.bfs(); &#x2F;&#x2F; A-&gt;B-&gt;C-&gt;D-E [1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8]
    &#125;

    &#x2F;&#x2F;构造器
    public Graph(int n) &#123;
        &#x2F;&#x2F;初始化矩阵和vertexList
        edges &#x3D; new int[n][n];
        vertexList &#x3D; new ArrayList&lt;String&gt;(n);
        numOfEdges &#x3D; 0;

    &#125;

    &#x2F;&#x2F;图中常用的方法
    &#x2F;&#x2F;返回结点的个数
    public int getNumOfVertex() &#123;
        return vertexList.size();
    &#125;
    &#x2F;&#x2F;显示图对应的矩阵
    public void showGraph() &#123;
        for(int[] link : edges) &#123;
            System.err.println(Arrays.toString(link));
        &#125;
    &#125;
    &#x2F;&#x2F;得到边的数目
    public int getNumOfEdges() &#123;
        return numOfEdges;
    &#125;
    &#x2F;&#x2F;返回结点i(下标)对应的数据 0-&gt;&quot;A&quot; 1-&gt;&quot;B&quot; 2-&gt;&quot;C&quot;
    public String getValueByIndex(int i) &#123;
        return vertexList.get(i);
    &#125;
    &#x2F;&#x2F;返回v1和v2的权值
    public int getWeight(int v1, int v2) &#123;
        return edges[v1][v2];
    &#125;
    &#x2F;&#x2F;插入结点
    public void insertVertex(String vertex) &#123;
        vertexList.add(vertex);
    &#125;
    &#x2F;&#x2F;添加边
    &#x2F;**
     *
     * @param v1 表示点的下标即使第几个顶点  &quot;A&quot;-&quot;B&quot; &quot;A&quot;-&gt;0 &quot;B&quot;-&gt;1
     * @param v2 第二个顶点对应的下标
     * @param weight 表示
     *&#x2F;
    public void insertEdge(int v1, int v2, int weight) &#123;
        edges[v1][v2] &#x3D; weight;
        edges[v2][v1] &#x3D; weight;
        numOfEdges++;
    &#125;
    &#x2F;&#x2F;得到第一个邻接结点的下标 w
    &#x2F;**
     *
     * @param index
     * @return 如果存在就返回对应的下标，否则返回-1
     *&#x2F;
    public int getFirstNeighbor(int index)&#123;
        for (int i &#x3D; 0;i &lt; getNumOfVertex();i++)&#123;
            if (edges[index][i] &gt; 0)&#123;
                return i;
            &#125;
        &#125;
        return -1;
    &#125;
    &#x2F;&#x2F;根据前一个邻接结点的下标来获取下一个邻接结点  v1,v2是前一个邻接节点的下标
    public int getNextNeighbor(int v1, int v2) &#123;
        for (int j &#x3D; v2 + 1;j &lt; getNumOfVertex();j++)&#123;
            if (edges[v1][j] &gt; 0)&#123;
                return j;
            &#125;
        &#125;
        return -1;
    &#125;

    &#x2F;&#x2F;深度优先遍历算法
    &#x2F;&#x2F;i 第一次就是 0
    private void dfs(boolean[] isVisited, int i)&#123;
        System.out.print(getValueByIndex(i) + &quot;-&gt;&quot;);
        isVisited[i] &#x3D; true;
        int w &#x3D; getFirstNeighbor(i);
        while (w!&#x3D;-1)&#123;
            if (!isVisited[w])&#123;
                dfs(isVisited,w);
            &#125;
            w &#x3D; getNextNeighbor(i,w);
        &#125;
    &#125;

    public void dfs()&#123;
        isVisited &#x3D; new boolean[vertexList.size()];
        &#x2F;&#x2F;遍历所有的结点，进行dfs[回溯]
        for(int i &#x3D; 0; i &lt; getNumOfVertex(); i++) &#123;
            if(!isVisited[i]) &#123;
                dfs(isVisited, i);
            &#125;
        &#125;
    &#125;

    &#x2F;&#x2F;对一个结点进行广度优先遍历的方法
    private void bfs(boolean[] isVisited, int i) &#123;
        int u ; &#x2F;&#x2F; 表示队列的头结点对应下标
        int w ; &#x2F;&#x2F; 邻接结点w
        &#x2F;&#x2F;队列，记录结点访问的顺序
        LinkedList queue &#x3D; new LinkedList();
        &#x2F;&#x2F;访问结点，输出结点信息
        System.out.print(getValueByIndex(i) + &quot;&#x3D;&gt;&quot;);
        &#x2F;&#x2F;标记为已访问
        isVisited[i] &#x3D; true;
        &#x2F;&#x2F;将结点加入队列
        queue.addLast(i);

        while( !queue.isEmpty()) &#123;
            &#x2F;&#x2F;取出队列的头结点下标
            u &#x3D; (Integer)queue.removeFirst();
            &#x2F;&#x2F;得到第一个邻接结点的下标 w
            w &#x3D; getFirstNeighbor(u);
            while(w !&#x3D; -1) &#123;&#x2F;&#x2F;找到
                &#x2F;&#x2F;是否访问过
                if(!isVisited[w]) &#123;
                    System.out.print(getValueByIndex(w) + &quot;&#x3D;&gt;&quot;);
                    &#x2F;&#x2F;标记已经访问
                    isVisited[w] &#x3D; true;
                    &#x2F;&#x2F;入队
                    queue.addLast(w);
                &#125;
                &#x2F;&#x2F;以u为前驱点，找w后面的下一个邻结点
                w &#x3D; getNextNeighbor(u, w); &#x2F;&#x2F;体现出我们的广度优先
            &#125;
        &#125;

    &#125;

    &#x2F;&#x2F;遍历所有的结点，都进行广度优先搜索
    public void bfs() &#123;
        isVisited &#x3D; new boolean[vertexList.size()];
        for(int i &#x3D; 0; i &lt; getNumOfVertex(); i++) &#123;
            if(!isVisited[i]) &#123;
                bfs(isVisited, i);
            &#125;
        &#125;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="13-7-图的深度优先VS-广度优先"><a href="#13-7-图的深度优先VS-广度优先" class="headerlink" title="13.7 图的深度优先VS 广度优先"></a>13.7 图的深度优先VS 广度优先</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646492640048.png" alt="1646492640048"></p>
<h3 id="14-常用的10种算法"><a href="#14-常用的10种算法" class="headerlink" title="14 常用的10种算法"></a>14 常用的10种算法</h3><h4 id="14-1-二分查找-递归"><a href="#14-1-二分查找-递归" class="headerlink" title="14.1 二分查找(递归)"></a>14.1 二分查找(递归)</h4><h5 id="14-1-1-概述"><a href="#14-1-1-概述" class="headerlink" title="14.1.1 概述"></a>14.1.1 概述</h5><p>二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找。</p>
<p>二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n&#x3D;100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 &lt; 100 &lt; 2^7)。</p>
<h5 id="14-1-2-实现"><a href="#14-1-2-实现" class="headerlink" title="14.1.2 实现"></a>14.1.2 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.List;

&#x2F;&#x2F;注意：使用二分查找的前提是 该数组是有序的.
public class BinarySearch &#123;

	public static void main(String[] args) &#123;
		int arr[] &#x3D; &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,14,14,15,16,17,18,19,20 &#125;;

		int resIndex &#x3D; binarySearch(arr, 0, arr.length - 1, 1);
		System.out.println(&quot;resIndex&#x3D;&quot; + resIndex);
	&#125;

	&#x2F;&#x2F; 二分查找算法
	&#x2F;**
	 * 
	 * @param arr
	 *            数组
	 * @param left
	 *            左边的索引
	 * @param right
	 *            右边的索引
	 * @param findVal
	 *            要查找的值
	 * @return 如果找到就返回下标，如果没有找到，就返回 -1
	 *&#x2F;
	public static int binarySearch(int[] arr, int left, int right, int findVal) &#123;

		&#x2F;&#x2F; 当 left &gt; right 时，说明递归整个数组，但是没有找到
		if (left &gt; right) &#123;
			return -1;
		&#125;
		int mid &#x3D; (left + right) &#x2F; 2;
		int midVal &#x3D; arr[mid];

		if (findVal &gt; midVal) &#123; &#x2F;&#x2F; 向 右递归
			return binarySearch(arr, mid + 1, right, findVal);
		&#125; else if (findVal &lt; midVal) &#123; &#x2F;&#x2F; 向左递归
			return binarySearch(arr, left, mid - 1, findVal);
		&#125; else &#123;
			
			return mid;
		&#125;

	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>有多个相同的数值时，将所有的数值都查找到，eg：{1,8, 10, 89, 1000, 1000，1234} 在这个有序数组中，查找里面的 1000。</p>
<p>思路分析：</p>
<ol>
<li>在找到mid 索引值，不要马上返回</li>
<li>向mid 索引值的左边扫描，将所有满足 1000的元素的下标，加入到集合ArrayList</li>
<li>向mid 索引值的右边扫描，将所有满足 1000的元素的下标，加入到集合ArrayList</li>
<li>将Arraylist返回</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.List;

&#x2F;&#x2F;注意：使用二分查找的前提是 该数组是有序的.
public class BinarySearch &#123;

	public static void main(String[] args) &#123;
		int arr[] &#x3D; &#123; 1, 8, 10, 89, 1000, 1000, 1234&#125;;
	
		List&lt;Integer&gt; resIndexList &#x3D; binarySearch2(arr, 0, arr.length - 1, 1000);
		System.out.println(&quot;resIndexList&#x3D;&quot; + resIndexList);
	&#125;

	public static List&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) &#123;

		System.out.println(&quot;hello~&quot;);
		&#x2F;&#x2F; 当 left &gt; right 时，说明递归整个数组，但是没有找到
		if (left &gt; right) &#123;
			return new ArrayList&lt;Integer&gt;();
		&#125;
		int mid &#x3D; (left + right) &#x2F; 2;
		int midVal &#x3D; arr[mid];

		if (findVal &gt; midVal) &#123; &#x2F;&#x2F; 向 右递归
			return binarySearch2(arr, mid + 1, right, findVal);
		&#125; else if (findVal &lt; midVal) &#123; &#x2F;&#x2F; 向左递归
			return binarySearch2(arr, left, mid - 1, findVal);
		&#125; else &#123;
            
			List&lt;Integer&gt; resIndexlist &#x3D; new ArrayList&lt;Integer&gt;();
			&#x2F;&#x2F;向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
			int temp &#x3D; mid - 1;
			while(true) &#123;
				if (temp &lt; 0 || arr[temp] !&#x3D; findVal) &#123;&#x2F;&#x2F;退出
					break;
				&#125;
				&#x2F;&#x2F;否则，就temp 放入到 resIndexlist
				resIndexlist.add(temp);
				temp -&#x3D; 1; &#x2F;&#x2F;temp左移
			&#125;
			resIndexlist.add(mid);  &#x2F;&#x2F;
			
			&#x2F;&#x2F;向mid 索引值的右边扫描，将所有满足 1000 的元素的下标，加入到集合ArrayList
			temp &#x3D; mid + 1;
			while(true) &#123;
				if (temp &gt; arr.length - 1 || arr[temp] !&#x3D; findVal) &#123;&#x2F;&#x2F;退出
					break;
				&#125;
				&#x2F;&#x2F;否则，就temp 放入到 resIndexlist
				resIndexlist.add(temp);
				temp +&#x3D; 1; &#x2F;&#x2F;temp右移
			&#125;			
			return resIndexlist;
		&#125;
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="14-2-分治算法"><a href="#14-2-分治算法" class="headerlink" title="14.2 分治算法"></a>14.2 分治算法</h4><h5 id="14-2-1-概述"><a href="#14-2-1-概述" class="headerlink" title="14.2.1 概述"></a>14.2.1 概述</h5><p>分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p>
<h5 id="14-2-2-算法分析"><a href="#14-2-2-算法分析" class="headerlink" title="14.2.2 算法分析"></a>14.2.2 算法分析</h5><ol>
<li><p>分解，将要解决的问题划分成若干规模较小的同类问题；</p>
</li>
<li><p>求解，当子问题划分得足够小时，用较简单的方法解决；</p>
</li>
<li><p>合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。</p>
</li>
</ol>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wps8F61.tmp.jpg" alt="img"> </p>
<p>​    假如把1 6硬币的例子看成一个大的问题。第一步，把这一问题分成两个小问题。随机选择8个硬币作为第一组称为A组，剩下的8个硬币作为第二组称为B组。这样，就把1 6个硬币的问题分成两个8硬币的问题来解决。第二步，判断A和B组中是否有伪币。可以利用仪器来比较A组硬币和B组硬币的重量。假如两组硬币重量相等，则可以判断伪币不存在。假如两组硬币重量不相等，则存在伪币，并且可以判断它位于较轻的那一组硬币中。最后，在第三步中，用第二步的结果得出原先1 6个硬币问题的答案。若仅仅判断硬币是否存在，则第三步非常简单。无论A组还是B组中有伪币，都可以推断这1 6个硬币中存在伪币。因此，仅仅通过一次重量的比较，就可以判断伪币是否存在。</p>
<h5 id="14-2-3-汉诺塔"><a href="#14-2-3-汉诺塔" class="headerlink" title="14.2.3 汉诺塔"></a>14.2.3 汉诺塔</h5><p>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsCA81.tmp.jpg" alt="img"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hanoitower &#123;
	public static void main(String[] args) &#123;
		hanoiTower(10, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);
	&#125;
	
	&#x2F;&#x2F;汉诺塔的移动的方法
	&#x2F;&#x2F;使用分治算法	
	public static void hanoiTower(int num, char a, char b, char c) &#123;
		&#x2F;&#x2F;如果只有一个盘
		if(num &#x3D;&#x3D; 1) &#123;
			System.out.println(&quot;第1个盘从 &quot; + a + &quot;-&gt;&quot; + c);
		&#125; else &#123;
			&#x2F;&#x2F;如果我们有 n &gt;&#x3D; 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘
			&#x2F;&#x2F;1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c
			hanoiTower(num - 1, a, c, b);
			&#x2F;&#x2F;2. 把最下边的盘 A-&gt;C
			System.out.println(&quot;第&quot; + num + &quot;个盘从 &quot; + a + &quot;-&gt;&quot; + c);
			&#x2F;&#x2F;3. 把B塔的所有盘 从 B-&gt;C , 移动过程使用到 a塔  
			hanoiTower(num - 1, b, a, c);		
		&#125;
	&#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="14-3-动态规划算法"><a href="#14-3-动态规划算法" class="headerlink" title="14.3 动态规划算法"></a>14.3 动态规划算法</h4><h5 id="14-3-1-概述"><a href="#14-3-1-概述" class="headerlink" title="14.3.1 概述"></a>14.3.1 概述</h5><p>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</p>
<p>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</p>
<p>动态规划可以通过填表的方式来逐步推进，得到最优解。</p>
<h5 id="14-3-2-背包问题"><a href="#14-3-2-背包问题" class="headerlink" title="14.3.2 背包问题"></a>14.3.2 背包问题</h5><p>背包问题：有一个背包，容量为4磅 ， 现有如下物品：<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1646637830775.png" alt="1646637830775"></p>
<ol>
<li><p>要求达到的目标为装入的背包的总价值最大，并且重量不超出</p>
</li>
<li><p>要求装入的物品不能重复</p>
<p>思路分析和图解：</p>
<ol start="3">
<li>背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用)。</li>
<li>这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。</li>
<li>算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i] [j]表示在前i个物品中能够装入容量为j的背包中的最大价值。</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-算法分析" data-language="算法分析"><code class="language-算法分析">(1) v[i][0]&#x3D;v[0][j]&#x3D;0; &#x2F;&#x2F;表示 填入表 第一行和第一列是0
(2) 当w[i]&gt; j 时：v[i][j]&#x3D;v[i-1][j]   &#x2F;&#x2F; 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略
(3) 当j&gt;&#x3D;w[i]时：v[i][j]&#x3D;max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125;  
&#x2F;&#x2F; 当准备加入的新增的商品的容量小于等于当前背包的容量,
&#x2F;&#x2F; 装入的方式:
v[i-1][j]：就是上一个单元格的装入的最大值
v[i]：表示当前商品的价值 
v[i-1][j-w[i]]：装入i-1商品，到剩余空间j-w[i]的最大值
当j&gt;&#x3D;w[i]时：v[i][j]&#x3D;max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; : 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="14-3-3-实现"><a href="#14-3-3-实现" class="headerlink" title="14.3.3 实现"></a>14.3.3 实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class KnapsackProblem &#123;
    public static void main(String[] args) &#123;

        int[] w &#x3D; &#123;1, 4, 3&#125;;&#x2F;&#x2F;物品的重量
        int[] val &#x3D; &#123;1500, 3000, 2000&#125;; &#x2F;&#x2F;物品的价值 这里val[i] 就是前面讲的v[i]
        int m &#x3D; 4; &#x2F;&#x2F;背包的容量
        int n &#x3D; val.length; &#x2F;&#x2F;物品的个数

        &#x2F;&#x2F;创建二维数组，
        &#x2F;&#x2F;v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值
        int[][] v &#x3D; new int[n+1][m+1];
        &#x2F;&#x2F;为了记录放入商品的情况，定一个二维数组
        int[][] path &#x3D; new int[n+1][m+1];

        &#x2F;&#x2F;初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0
        for(int i &#x3D; 0; i &lt; v.length; i++) &#123;
            v[i][0] &#x3D; 0; &#x2F;&#x2F;将第一列设置为0
        &#125;
        for(int i&#x3D;0; i &lt; v[0].length; i++) &#123;
            v[0][i] &#x3D; 0; &#x2F;&#x2F;将第一行设置0
        &#125;

        &#x2F;&#x2F;根据前面得到公式来动态规划处理
        for(int i &#x3D; 1; i &lt; v.length; i++) &#123; &#x2F;&#x2F;不处理第一行 i是从1开始的
            for(int j&#x3D;1; j &lt; v[0].length; j++) &#123;&#x2F;&#x2F;不处理第一列, j是从1开始的
                &#x2F;&#x2F;公式
                if(w[i-1]&gt; j) &#123;
                    v[i][j]&#x3D;v[i-1][j];
                &#125; else &#123;
                    &#x2F;&#x2F;说明:
                    &#x2F;&#x2F;v[i][j]&#x3D;Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);
                    &#x2F;&#x2F;v[i][j] &#x3D; Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);
                    &#x2F;&#x2F;为了记录商品存放到背包的情况，不能直接的使用上面的公式，需要使用if-else来体现公式
                    if(v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]]) &#123;
                        v[i][j] &#x3D; val[i - 1] + v[i - 1][j - w[i - 1]];
                        &#x2F;&#x2F;把当前的情况记录到path
                        path[i][j] &#x3D; 1;
                    &#125; else &#123;
                        v[i][j] &#x3D; v[i - 1][j];
                    &#125;

                &#125;
            &#125;
        &#125;

        &#x2F;&#x2F;输出一下v
        for(int i &#x3D;0; i &lt; v.length;i++) &#123;
            for(int j &#x3D; 0; j &lt; v[i].length;j++) &#123;
                System.out.print(v[i][j] + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;

        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
        for(int i &#x3D; 0; i &lt; path.length; i++) &#123;
            for(int j&#x3D;0; j &lt; path[i].length; j++) &#123;
                System.out.print(path[i][j] + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;

        &#x2F;&#x2F;输出最后放入了哪些商品
        int i &#x3D; path.length - 1; &#x2F;&#x2F;行的最大下标
        int j &#x3D; path[0].length - 1;  &#x2F;&#x2F;列的最大下标
        while(i &gt; 0 &amp;&amp; j &gt; 0 ) &#123; &#x2F;&#x2F;从path的最后开始找
            if(path[i][j] &#x3D;&#x3D; 1) &#123;
                System.out.printf(&quot;第%d个商品放入到背包\n&quot;, i);
                j -&#x3D; w[i-1]; &#x2F;&#x2F;w[i-1]
            &#125;
            i--;
        &#125;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="14-3-4-向右或下走的最小路径"><a href="#14-3-4-向右或下走的最小路径" class="headerlink" title="14.3.4 向右或下走的最小路径"></a>14.3.4 向右或下走的最小路径</h5><p>给定一个矩阵m，从左上角开始每次只能向右走或者向下走，最后达到右下角的位置，路径中所有数字累加起来就是路径和，返回所有路径的最小路径和，如果给定的m如下，那么路径1,3,1,0,6,1,0就是最小路径和，返回12。</p>
<p>如下图：</p>
<p><img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsFBA5.tmp.jpg" alt="img"> <img src="file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml\wpsFBA6.tmp.jpg" alt="img"></p>
 <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MinPath &#123;

    public static void main(String[] args) &#123;

        int[][] arry &#x3D; &#123;&#123;1,3,5,9&#125;,&#123;8,1,3,4&#125;,&#123;5,0,6,1&#125;,&#123;8,8,4,0&#125;&#125;;
        for (int i&#x3D;0;i&lt;arry.length;i++)&#123;
            for (int j&#x3D;0;j&lt;arry[0].length;j++)&#123;
                System.out.print(arry[i][j] + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
        System.out.println(&quot;(方法一)最小路径和为&quot; + myanmic(arry));

        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);

        int m &#x3D; arry.length;
        int n &#x3D; arry[0].length;
        int[][] v &#x3D; new int[n][m];  &#x2F;&#x2F;最小路径图

        v[0][0] &#x3D; arry[0][0];
        int i &#x3D; 0;
        int j &#x3D; 0;

        &#x2F;&#x2F;比较右边和下边哪个值更小
        &#x2F;&#x2F;走到最后一列或者最后一行时，跳出循环
        while (true)&#123;
            if (arry[i+1][j] &gt;&#x3D; arry[i][j+1]) &#123;
                v[i][j + 1] &#x3D; v[i][j] + arry[i][j + 1];
                j++;
                if (j &#x3D;&#x3D; n-1)&#123;
                    break;
                &#125;
            &#125;else if (arry[i+1][j] &lt; arry[i][j+1] &amp;&amp; i&lt;m-1)&#123;
                v[i+1][j] &#x3D; v[i][j] + arry[i+1][j];
                i++;
                if (i &#x3D;&#x3D; m-1)&#123;
                    break;
                &#125;
            &#125;
        &#125;

        &#x2F;&#x2F;到了最后一列，只能往下走，向下赋值
        while (j&#x3D;&#x3D;n-1)&#123;
            i++;
            while (i&lt;m)&#123;
                v[i][j] &#x3D; v[i-1][j] + arry[i][j];
                i++;
            &#125;
            j++;
        &#125;
        &#x2F;&#x2F;到了最后一行，只能往右走，向右赋值
        while (i&#x3D;&#x3D;m-1)&#123;
            j++;
            while (j&lt;n)&#123;
                v[i][j + 1] &#x3D; v[i][j] + arry[i][j + 1];
                j++;
            &#125;
            i++;
        &#125;

        &#x2F;&#x2F;查看最小路径图
        for (int a&#x3D;0;a&lt;v.length;a++)&#123;
            for (int b&#x3D;0;b&lt;v[0].length;b++)&#123;
                System.out.print(v[a][b] + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;

        System.out.println(&quot;(方法二)最小路径和为&quot; + v[m-1][n-1]);
    &#125;

    &#x2F;**
     * 计算最小路径的之间的和
     * @param array
     * @return
     *&#x2F;
    public static int myanmic(int[][] array)&#123;
        if (array.length&#x3D;&#x3D;0)&#123;
            return 0;
        &#125;

        int[][] dp &#x3D; new int[array.length][array[0].length];
        dp[0][0] &#x3D; array[0][0];

        &#x2F;&#x2F;第一行从左边开始计算
        for (int i&#x3D;1;i&lt;dp[0].length;i++)&#123;
            &#x2F;&#x2F;最小路径是左边元素+自身元素则是最小值
            dp[0][i] &#x3D; dp[0][i-1] + array[0][i];
        &#125;

        for (int i&#x3D;1;i&lt;array.length;i++)&#123;&#x2F;&#x2F;遍历每一行
            for (int j&#x3D;0;j&lt;dp[i].length;j++)&#123;&#x2F;&#x2F;遍历每一列
                if (j&#x3D;&#x3D;0)&#123;&#x2F;&#x2F;表示最左边一列，最左边一列为上面第一行的同一列元素的最小路径+自身元素
                    dp[i][j] &#x3D; dp[i-1][j] + array[i][j];&#x2F;&#x2F;上面一行的同一列元素最小路径+自身元素
                &#125;else if (dp[i-1][j]&lt;dp[i][j-1])&#123;&#x2F;&#x2F;判断左边路径小还是上面一行元素路径小
                    dp[i][j] &#x3D; dp[i-1][j] + array[i][j];&#x2F;&#x2F;上面一行比较小
                &#125;else &#123;
                    dp[i][j] &#x3D; dp[i][j-1] + array[i][j];&#x2F;&#x2F;下面一行比较小，要是两遍相等，随便赋值哪一个都是一样的
                &#125;

            &#125;
        &#125;
        return dp[dp.length-1][dp[dp.length-1].length-1];&#x2F;&#x2F;输出dp右下角的元素
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="14-4-KMP算法"><a href="#14-4-KMP算法" class="headerlink" title="14.4 KMP算法"></a>14.4 KMP算法</h4><h5 id="14-4-1-概述"><a href="#14-4-1-概述" class="headerlink" title="14.4.1 概述"></a>14.4.1 概述</h5><p>KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法。</p>
<p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。</p>
<p>KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间。</p>
<h5 id="14-4-2-字符串匹配问题"><a href="#14-4-2-字符串匹配问题" class="headerlink" title="14.4.2 字符串匹配问题"></a>14.4.2 字符串匹配问题</h5><p>有一个字符串 str1&#x3D; “BBA ABCDAB ABCDABCDABDE”，和一个子串 str2&#x3D;”ABCDABD”</p>
<p>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</p>
<h5 id="14-4-3-暴力匹配算法"><a href="#14-4-3-暴力匹配算法" class="headerlink" title="14.4.3 暴力匹配算法"></a>14.4.3 暴力匹配算法</h5><p>如果用暴力匹配的思路，并假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有:</p>
<ol>
<li><p>如果当前字符匹配成功（即str1[i] &#x3D;&#x3D; str2[j]），则i++，j++，继续匹配下一个字符</p>
</li>
<li><p>如果失配（即str1[i]! &#x3D; str2[j]），令i &#x3D; i - (j - 1)，j &#x3D; 0。相当于每次匹配失败时，i 回溯，j 被置为0。</p>
</li>
<li><p>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)</p>
</li>
<li><p>暴力匹配算法实现.</p>
</li>
</ol>
<h5 id="14-4-4-暴力匹配算法实现"><a href="#14-4-4-暴力匹配算法实现" class="headerlink" title="14.4.4 暴力匹配算法实现"></a>14.4.4 暴力匹配算法实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ViolenceMatch &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;测试暴力匹配算法
        String str1 &#x3D; &quot;BBA ABCDAB ABCDABCDABDE&quot;;
        String str2 &#x3D; &quot;ABCDABD&quot;;
        int index &#x3D; violenceMatch(str1, str2);
        System.out.println(&quot;index&#x3D;&quot; + index);

    &#125;

    &#x2F;&#x2F; 暴力匹配算法实现
    public static int violenceMatch(String str1, String str2)&#123;
        char[] s1 &#x3D; str1.toCharArray();
        char[] s2 &#x3D; str2.toCharArray();

        int l1 &#x3D; s1.length;
        int l2 &#x3D; s2.length;
        int i&#x3D;0,j&#x3D;0;

        while (i &lt; l1 &amp;&amp; j &lt; l2)&#123;
            if(s1[i] &#x3D;&#x3D; s2[j])&#123;
                i++;
                j++;
            &#125;else &#123;
                i &#x3D; (i - j) + 1;
                j&#x3D;0;
            &#125;
        &#125;

        if (j &#x3D;&#x3D; l2)&#123;
            return i - j;
        &#125;else &#123;
            return -1;
        &#125;

    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="14-4-5-KMP算法实现"><a href="#14-4-5-KMP算法实现" class="headerlink" title="14.4.5 KMP算法实现"></a>14.4.5 KMP算法实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;

public class KMPAlgorithm &#123;

	public static void main(String[] args) &#123;
		String str1 &#x3D; &quot;BBC ABCDAB ABCDABCDABDE&quot;;
		String str2 &#x3D; &quot;ABCDABD&quot;;
		&#x2F;&#x2F;String str2 &#x3D; &quot;BBC&quot;;
		
		int[] next &#x3D; kmpNext(&quot;ABCDABD&quot;); &#x2F;&#x2F;[0, 1, 2, 0]
		System.out.println(&quot;next&#x3D;&quot; + Arrays.toString(next));
		
		int index &#x3D; kmpSearch(str1, str2, next);
		System.out.println(&quot;index&#x3D;&quot; + index); &#x2F;&#x2F; 15了
		
		
	&#125;
	
	&#x2F;&#x2F;kmp搜索算法
	&#x2F;**
	 * 
	 * @param str1 源字符串
	 * @param str2 子串
	 * @param next 部分匹配表, 是子串对应的部分匹配表
	 * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置
	 *&#x2F;
	public static int kmpSearch(String str1, String str2, int[] next) &#123;
		
		&#x2F;&#x2F;遍历 
		for(int i &#x3D; 0, j &#x3D; 0; i &lt; str1.length(); i++) &#123;
			
			&#x2F;&#x2F;需要处理 str1.charAt(i) ！&#x3D; str2.charAt(j), 去调整j的大小
			&#x2F;&#x2F;KMP算法核心点, 可以验证...
			while( j &gt; 0 &amp;&amp; str1.charAt(i) !&#x3D; str2.charAt(j)) &#123;
				j &#x3D; next[j-1]; 
			&#125;
			
			if(str1.charAt(i) &#x3D;&#x3D; str2.charAt(j)) &#123;
				j++;
			&#125;			
			if(j &#x3D;&#x3D; str2.length()) &#123;&#x2F;&#x2F;找到了 &#x2F;&#x2F; j &#x3D; 3 i 
				return i - j + 1;
			&#125;
		&#125;
		return  -1;
	&#125;

	&#x2F;&#x2F;获取到一个字符串(子串) 的部分匹配值表
	public static  int[] kmpNext(String dest) &#123;
		&#x2F;&#x2F;创建一个next 数组保存部分匹配值
		int[] next &#x3D; new int[dest.length()];
		next[0] &#x3D; 0; &#x2F;&#x2F;如果字符串是长度为1 部分匹配值就是0
		for(int i &#x3D; 1, j &#x3D; 0; i &lt; dest.length(); i++) &#123;
			&#x2F;&#x2F;当dest.charAt(i) !&#x3D; dest.charAt(j) ，需要从next[j-1]获取新的j
			&#x2F;&#x2F;直到发现 有 dest.charAt(i) &#x3D;&#x3D; dest.charAt(j)成立才退出
			&#x2F;&#x2F;这时kmp算法的核心点
			while(j &gt; 0 &amp;&amp; dest.charAt(i) !&#x3D; dest.charAt(j)) &#123;
				j &#x3D; next[j-1];
			&#125;
			
			&#x2F;&#x2F;当dest.charAt(i) &#x3D;&#x3D; dest.charAt(j) 满足时，部分匹配值就是+1
			if(dest.charAt(i) &#x3D;&#x3D; dest.charAt(j)) &#123;
				j++;
			&#125;
			next[i] &#x3D; j;
		&#125;
		return next;
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">申乔天</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://www.sqtsqt.online/2022/03/12/40445.html/">http://www.sqtsqt.online/2022/03/12/40445.html/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">申乔天</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">
                                    <span class="chip bg-color">数据结构与算法</span>
                                </a>
                            
                                <a href="/tags/java/">
                                    <span class="chip bg-color">java</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/03/14/15907.html/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="服务器与github博客搭建的整合">
                        
                        <span class="card-title">服务器与github博客搭建的整合</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-03-14
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" class="post-category">
                                    搭建博客
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">
                        <span class="chip bg-color">云服务器</span>
                    </a>
                    
                    <a href="/tags/github/">
                        <span class="chip bg-color">github</span>
                    </a>
                    
                    <a href="/tags/%E5%AE%9D%E5%A1%94/">
                        <span class="chip bg-color">宝塔</span>
                    </a>
                    
                    <a href="/tags/hexo/">
                        <span class="chip bg-color">hexo</span>
                    </a>
                    
                    <a href="/tags/linux/">
                        <span class="chip bg-color">linux</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/11/04/16107.html/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Hello World">
                        
                        <span class="card-title">Hello World</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            申乔天
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="122437098"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">申乔天</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">36.3k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/sqtsqt" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1224370498@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1224370498" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1224370498" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
